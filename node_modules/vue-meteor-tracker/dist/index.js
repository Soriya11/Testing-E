import { Tracker } from 'meteor/tracker';
import { Meteor } from 'meteor/meteor';
import { computed, getCurrentInstance, markRaw, onUnmounted, reactive, ref, watch, watchEffect } from 'vue';
export const config = {
    subscribe: Meteor.subscribe,
};
function autorun(callback) {
    const result = ref();
    const stop = watchEffect((onInvalidate) => {
        const computation = Tracker.autorun(() => {
            let value = callback();
            if (typeof value?.fetch === 'function') {
                value = value.fetch();
            }
            result.value = value && typeof value === 'object' ? markRaw(value) : value;
        });
        onInvalidate(() => {
            computation.stop();
        });
    });
    return {
        result: computed(() => result.value),
        stop,
    };
}
function subscribe(payload, ...args) {
    if (typeof payload === 'string') {
        return simpleSubscribe(payload, ...args);
    }
    else {
        return watchSubscribe(payload);
    }
}
function simpleSubscribe(name, ...args) {
    const sub = config.subscribe(name, ...args);
    const ready = autorun(() => sub.ready());
    function stop() {
        ready.stop();
        sub.stop();
    }
    getCurrentInstance() && onUnmounted(() => {
        stop();
    });
    return {
        stop,
        ready: ready.result,
        sub,
    };
}
function watchSubscribe(callback) {
    const ready = ref(false);
    const sub = ref();
    const stop = watch(callback, (value, oldValue, onInvalidate) => {
        if (value !== false) {
            sub.value = markRaw(config.subscribe(...value));
            const computation = Tracker.autorun(() => {
                ready.value = sub.value.ready();
            });
            onInvalidate(() => {
                sub.value.stop();
                computation.stop();
            });
        }
    }, {
        immediate: true,
        deep: true,
    });
    return {
        stop,
        ready: computed(() => ready.value),
        get sub() {
            return sub.value;
        },
    };
}
function makeComposable(name, fn) {
    return () => {
        const effects = [];
        const _run = ((...args) => {
            const effect = fn(...args);
            effects.push(effect);
            return effect;
        });
        onUnmounted(() => {
            effects.forEach(effect => effect.stop());
        });
        return {
            [name]: _run,
        };
    };
}
export const useAutorun = makeComposable('autorun', autorun);
export const useSubscribe = makeComposable('subscribe', subscribe);
function makeSetupOnlyFunction(fn) {
    return ((...args) => {
        if (process.env.NODE_ENV !== 'production') {
            if (!getCurrentInstance()) {
                console.warn(`'${fn.name}()' should only be used in setup() inside components to clean up correctly. If you need to call '${fn.name}' later outside of the setup context, use 'use${fn.name[0].toUpperCase()}${fn.name.slice(1)}()' instead.`);
            }
        }
        return fn(...args);
    });
}
const setupOnlyAutorun = makeSetupOnlyFunction(autorun);
const setupOnlySubscribe = makeSetupOnlyFunction(subscribe);
export { setupOnlyAutorun as autorun, setupOnlySubscribe as subscribe, };
export function callMethod(methodName, ...args) {
    return new Promise((resolve, reject) => {
        Meteor.call(methodName, ...args, (err, res) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(res);
            }
        });
    });
}
export function useMethod(name) {
    const pending = ref(false);
    const error = ref();
    const result = ref();
    const callbacks = [];
    async function call(...args) {
        pending.value = true;
        error.value = undefined;
        try {
            result.value = await callMethod(name, ...args);
            return result.value;
        }
        catch (e) {
            error.value = e;
        }
        finally {
            pending.value = false;
            callbacks.forEach(callback => callback(error.value, result.value));
        }
    }
    function onResult(callback) {
        callbacks.push(callback);
    }
    return {
        call,
        pending,
        error,
        result,
        onResult,
    };
}
export const VueMeteor = {
    install(app) {
        app.mixin({
            beforeCreate() {
                if (this.$options.meteor) {
                    const subReady = reactive({});
                    if (this.$options.meteor.$subscribe) {
                        for (const key in this.$options.meteor.$subscribe) {
                            const value = this.$options.meteor.$subscribe[key];
                            const { ready } = typeof value === 'function'
                                ? subscribe(() => {
                                    const result = value.call(this);
                                    return [key, ...result];
                                })
                                : subscribe(key, ...value);
                            // @ts-expect-error unwrapping
                            subReady[key] = ready;
                        }
                    }
                    this.$options.computed = this.$options.computed || {};
                    this.$options.computed.$subReady = () => subReady;
                    const { subscribe: $subscribe } = useSubscribe();
                    this.$options.methods = this.$options.methods || {};
                    this.$options.methods.$subscribe = $subscribe;
                    for (const key in this.$options.meteor) {
                        if (key.startsWith('$'))
                            continue;
                        const fn = this.$options.meteor[key];
                        const { result } = autorun(fn.bind(this));
                        this.$options.computed[key] = () => result.value;
                    }
                }
            },
        });
    },
};
