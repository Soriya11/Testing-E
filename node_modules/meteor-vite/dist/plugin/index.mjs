// src/plugin/Meteor.ts
import Path4 from "path";
import pc8 from "picocolors";

// package.json
var package_default = {
  name: "meteor-vite",
  version: "1.10.4",
  description: "",
  files: [
    "dist"
  ],
  main: "",
  exports: {
    "./plugin": {
      import: [
        "./dist/plugin/index.mjs"
      ],
      require: [
        "./dist/plugin/index.js"
      ]
    },
    "./client": "./dist/client/index.mjs"
  },
  scripts: {
    start: "ts-node-dev src/bin/debug/watch-mocks.ts",
    watch: "tsup --watch --dts --sourcemap",
    build: "rm -rf ./dist && tsup-node",
    prepare: "npm run build",
    test: "vitest"
  },
  tsup: [
    {
      entry: [
        "./src/bin/worker.ts",
        "./src/client/index.ts"
      ],
      outDir: "dist",
      format: "esm",
      sourcemap: true,
      dts: false
    },
    {
      entry: [
        "./src/plugin/index.ts"
      ],
      outDir: "dist/plugin",
      format: [
        "cjs",
        "esm"
      ],
      sourcemap: true,
      dts: true
    }
  ],
  typesVersions: {
    "*": {
      plugin: [
        "./dist/plugin/index.d.mts",
        "./dist/plugin/index.d.ts"
      ],
      client: [
        "./dist/client/index.d.mts"
      ]
    }
  },
  keywords: [
    "meteor",
    "vite"
  ],
  author: "",
  bugs: {
    url: "https://github.com/JorgenVatle/meteor-vite/issues"
  },
  homepage: "https://github.com/JorgenVatle/meteor-vite#readme",
  license: "ISC",
  dependencies: {
    "@babel/parser": "^7.22.5",
    "@babel/traverse": "^7.22.5",
    "p-limit": "^3.1.0",
    picocolors: "^1.0.0"
  },
  peerDependencies: {
    vite: ">=3.0.0 < 5.0.0"
  },
  devDependencies: {
    "@babel/generator": "^7.23.6",
    "@babel/types": "^7.22.5",
    "@sveltejs/vite-plugin-svelte": "^2.4.2",
    "@types/babel__generator": "^7.6.8",
    "@types/node": "^20.3.3",
    "ts-node-dev": "^2.0.0",
    tsup: "^7.1.0",
    typescript: "^5.1.6",
    vite: "^4.4.3",
    vitest: "^0.32.2"
  }
};

// src/error/MeteorViteError.ts
import { inspect } from "util";
import pc from "picocolors";
var divColor = (text) => pc.dim(text);
var MeteorViteError = class extends Error {
  constructor(originalMessage, { cause, context, package: meteorPackage, subtitle } = {}) {
    super(originalMessage);
    this.originalMessage = originalMessage;
    this.subtitle = subtitle;
    this.cause = cause;
    this.context = context;
    this.package = meteorPackage;
    if (cause instanceof Error && !subtitle) {
      this.subtitle = `Caused by [${cause?.name}] ${cause?.message}`;
    }
    if (cause) {
      this.addSection("Caused by", cause);
    }
  }
  package;
  context;
  cause;
  subtitle;
  metadataLines = [];
  addLine(...lines) {
    if (Array.isArray(lines[0])) {
      lines = lines[0];
    }
    const whitespace = "  ";
    this.metadataLines.push(`${whitespace}${lines.join(whitespace)}`);
  }
  setContext(loadRequest) {
    this.context = loadRequest.context;
  }
  async formatLog() {
  }
  addSection(title, object) {
    const content = inspect(object, { colors: true });
    const divider = this.titleDivider({
      title: `[${title}]`,
      indent: 2
    });
    this.addLine(divider);
    content.split(/[\r\n]+/).forEach((line) => {
      this.addLine(`${divColor("|")}  ${line}`);
    });
  }
  titleDivider({
    title = "",
    addLength = 0,
    divider = "-",
    indent = 0
  }) {
    divider = divColor(divider);
    let repeatCount = 85 - title.length + addLength - indent;
    if (repeatCount < 1) {
      return title;
    }
    return `${divider.repeat(indent)}${title}${divider.repeat(repeatCount)}`;
  }
  async beautify() {
    await this.formatLog();
    const moduleId = this.context?.id.replace("meteor/", "") || this.package?.packageId;
    const moduleString = moduleId && pc.yellow(`
\u26A1   <${moduleId}>`) || "";
    this.name = `

${this.titleDivider({
      title: `[${this.constructor.name}]`,
      divider: "_",
      indent: 6
    })}${moduleString}`;
    this.message = [
      "",
      "",
      `${pc.bgRed(pc.bold(" ERROR "))} ${this.message}`,
      `${pc.dim(this.subtitle)}`,
      "",
      ...this.metadataLines,
      this.titleDivider({
        title: "[Error Stack]",
        indent: 2
      })
    ].filter((line, index) => {
      if (typeof line !== "string") {
        return false;
      }
      if (index === 1 && !this.subtitle) {
        return false;
      }
      return true;
    }).join("\n");
    const endOfLog = this.titleDivider({ divider: "_" });
    const reportIssue = ` \u{1F41B}  Report an issue:
  -  ${package_default.bugs.url}`;
    this.stack = `${this.stack}

${reportIssue}
${endOfLog}
`;
    if (!this.cause) {
      this.clearProperties(["cause"]);
    }
    this.clearProperties([
      "subtitle",
      "originalMessage",
      "package",
      "context",
      "metadataLines"
    ]);
  }
  clearProperties(keys) {
    keys.forEach((key) => delete this[key]);
  }
};
var FatalMeteorViteError = class extends MeteorViteError {
};

// src/plugin/MeteorStubs.ts
import FS4 from "fs/promises";
import Path3 from "path";
import pc7 from "picocolors";

// src/ViteLoadRequest.ts
import NodeFS, { existsSync } from "fs";
import FS3 from "fs/promises";
import Path2 from "path";
import pc6 from "picocolors";

// src/meteor/package/AutoImportQueue.ts
import FS from "fs/promises";
import pc3 from "picocolors";

// src/utilities/Logger.ts
import pc2 from "picocolors";
function createLogger(formatter) {
  return {
    info: (...params) => console.log(...formatMessage(formatter(...params))),
    warn: (...params) => console.warn(...formatMessage(formatter(...params))),
    error: (...params) => console.error(...formatMessage(formatter(...params))),
    debug: (...params) => process.env.ENABLE_DEBUG_LOGS && console.debug(...formatMessage(formatter(...params)))
  };
}
function formatMessage([message, ...params]) {
  if (message instanceof MeteorViteError) {
    message.beautify().then(() => console.warn(message, ...params));
    return [];
  }
  if (typeof message === "string") {
    return [`\u26A1  ${message}`, ...params];
  }
  return [message, ...params];
}
var createLabelledLogger = (label) => createLogger((message, dataLines) => {
  if (!Array.isArray(dataLines)) {
    dataLines = Object.entries(dataLines);
  }
  const data = dataLines.map(([key, value]) => {
    return `
 ${pc2.dim("L")}  ${key}: ${value}`;
  }).join("");
  return [`${label} ${message}${data}`];
});
var Logger_default = createLogger((...params) => params);

// src/meteor/IPC/MeteorEvents.ts
import { EventEmitter } from "events";
var MeteorEventBus = class {
  events = new EventEmitter();
  /**
   * Wait for one of the provided IPC message topics before resolving the promise.
   *
   * @param {{topics: MeteorIPCTopic[], timeoutMs: number}} event
   * @returns {Promise<void>}
   */
  waitForMessage(event) {
    const awaitedEvents = event.topic.map((topic) => awaitEvent({
      emitter: this.events,
      name: topic,
      timeoutMs: event.timeoutMs
    }));
    return Promise.race(awaitedEvents);
  }
  ingest(message) {
    Logger_default.debug("Received Meteor IPC message:", message);
    this.events.emit(message.topic);
  }
};
function awaitEvent(event) {
  return new Promise((_resolve, _reject) => {
    let rejected = false;
    let resolved = false;
    const listener = (data) => {
      resolve(data);
    };
    const reject = (error) => {
      if (resolved || rejected)
        return;
      rejected = true;
      event.emitter.removeListener(event.name, listener);
      _reject(error);
    };
    const resolve = (data) => {
      if (resolved || rejected)
        return;
      resolved = true;
      _resolve(data);
    };
    event.emitter.once(event.name, listener);
    setTimeout(() => reject(new EventTimeout(`Timed out waiting for event: ${String(event.name)}`)), event.timeoutMs);
  });
}
var MeteorEvents = new MeteorEventBus();
var EventTimeout = class extends Error {
};
var MeteorEvents_default = MeteorEvents;

// src/meteor/package/StubTemplate.ts
var METEOR_STUB_KEY = `m2`;
var PACKAGE_SCOPE_KEY = "m";
var TEMPLATE_GLOBAL_KEY = "g";
function stubTemplate({ requestId, meteorPackage, importPath, stubValidation: validationSettings }) {
  const stubId = getStubId();
  const { packageId } = meteorPackage;
  const submodule = meteorPackage.getModule({ importPath });
  const serializedPackage = meteorPackage.serialize({ importPath });
  const fullImportPath = submodule?.fullImportPath || packageId;
  const stubValidation = stubValidationTemplate({
    packageId,
    requestId,
    settings: validationSettings,
    exportKeys: serializedPackage.exportKeys
  });
  return `
// requestId: ${requestId}
// packageId: ${packageId}

${stubValidation.importString}
const ${TEMPLATE_GLOBAL_KEY} = typeof window !== 'undefined' ? window : global;
${serializedPackage.imports.join("\n")}
${serializedPackage.reExports.join("\n")}

let ${METEOR_STUB_KEY};
const require = Package.modules.meteorInstall({
  '__vite_stub${stubId}.js': (require, exports, module) => {
      ${METEOR_STUB_KEY} = require('${fullImportPath}');
      
      ${stubValidation.validateStub}
  }
}, {
  "extensions": [
    ".js"
  ]
})
require('/__vite_stub${stubId}.js')

${serializedPackage.exports.join("\n")}
`;
}
var REGEX_AUTO_IMPORT_BLOCK = /(?<startBlock>\*\*\/[\r\n\s]+)(?<imports>(?:.*[\r\n])*)(?<endBlock>[\s\r\n]*\/\*\* End of vite[\-:]bundler auto-imports \*\*\/)/;
function viteAutoImportBlock({ content, id }) {
  let { startBlock, imports, endBlock } = content.match(REGEX_AUTO_IMPORT_BLOCK)?.groups || { imports: "" };
  imports += `import '${id}';
`;
  imports = imports.trim();
  if (endBlock && startBlock) {
    return content.replace(REGEX_AUTO_IMPORT_BLOCK, `${startBlock.trim()}
${imports}
${endBlock.trim()}`);
  }
  return `/**
 * These modules are automatically imported by jorgenvatle:vite-bundler.
 * You can commit these to your project or move them elsewhere if you'd like,
 * but they must be imported somewhere in your Meteor entrypoint file.
 *
 * More info: https://github.com/JorgenVatle/meteor-vite#lazy-loaded-meteor-packages
**/
${imports}
/** End of vite-bundler auto-imports **/

${content}`;
}
function stubValidationTemplate({ settings, requestId, exportKeys, packageId }) {
  if (settings?.disabled) {
    return {
      importString: "",
      validateStub: ""
    };
  }
  if (settings?.ignorePackages?.includes(packageId)) {
    return {
      importString: "",
      // language=js
      validateStub: `console.debug("Stub validation disabled for '${packageId}'");`
    };
  }
  const validatorOptions = {
    requestId,
    packageName: packageId,
    exportKeys,
    warnOnly: settings?.warnOnly
  };
  const importString = `import { validateStub } from 'meteor-vite/client';`;
  const validateStub = `validateStub(${METEOR_STUB_KEY}, ${JSON.stringify(validatorOptions)});`;
  return {
    importString,
    validateStub
  };
}
var nextStubId = 0;
function getStubId() {
  return nextStubId++;
}

// src/meteor/package/AutoImportQueue.ts
import PLimit from "p-limit";
var AutoImportQueue = class {
  restartTimeout;
  addedPackages = [];
  queueWrite = PLimit(1);
  onRestartWatchers = [];
  /**
   * Once an import is added for a lazy-loaded package, the Meteor server needs to restart in order for the
   * package to become available to Vite.
   *
   * This countdown timer will start from the first auto-import and reset with every following import request
   * within the time limit. If no more requests are received, the server will finally restart.
   * @type {number}
   */
  RESTART_COUNTDOWN_MS = 2500;
  /**
   * Queues auto-imports for writing to disk to avoid race-conditions with concurrent write requests to the same file.
   */
  async write({ importString, meteorEntrypoint, skipRestart }) {
    const lastPackageCount = this.addedPackages.length;
    const content = await FS.readFile(meteorEntrypoint, "utf-8");
    if (content.includes(`'${importString}'`)) {
      Logger_default.debug('Skipping auto-import for "%s" as it already has all the necessary imports', importString);
      return;
    }
    await this.queueWrite(async () => {
      const content2 = await FS.readFile(meteorEntrypoint, "utf-8");
      const newContent = viteAutoImportBlock({
        id: importString,
        content: content2
      });
      await FS.writeFile(meteorEntrypoint, newContent);
      this.addedPackages.push(importString);
      const logMessage = skipRestart ? 'Added auto-import for "%s" - you may need to refresh your client manually' : 'Added auto-import for "%s" - waiting for Meteor to refresh the client';
      Logger_default.info(logMessage, importString);
    });
    if (this.addedPackages.length > lastPackageCount && !skipRestart) {
      await MeteorEvents_default.waitForMessage({
        topic: ["webapp-reload-client", "client-refresh"],
        timeoutMs: process.env.NODE_ENV === "test" ? 50 : 15e3
        // todo: implement tests for this
      }).catch((error) => {
        if (error instanceof EventTimeout) {
          Logger_default.warn(`Timed out waiting for Meteor to refresh the client for ${pc3.yellow(importString)}!`);
          return this.scheduleRestart();
        }
        throw error;
      });
    }
  }
  scheduleRestart() {
    if (this.restartTimeout) {
      clearTimeout(this.restartTimeout);
    }
    this.restartTimeout = setTimeout(() => {
      this.onRestartWatchers.forEach((callListener) => callListener());
    }, this.RESTART_COUNTDOWN_MS);
    return new Promise((resolve, reject) => {
      this.onRestartWatchers.push(() => {
        reject(
          new RefreshNeeded(`Terminating Vite server to load isopacks for new packages`, this.addedPackages)
        );
      });
    });
  }
};
var AutoImportQueueInstance = new AutoImportQueue();
var AutoImportQueue_default = AutoImportQueueInstance;

// src/meteor/package/components/MeteorPackage.ts
import Path from "path";

// src/meteor/parser/Parser.ts
import { parse } from "@babel/parser";
import {
  is as is2,
  isCallExpression as isCallExpression2,
  isFunctionExpression,
  isIdentifier as isIdentifier2,
  isMemberExpression as isMemberExpression2,
  isObjectExpression as isObjectExpression3,
  isObjectProperty as isObjectProperty2,
  isReturnStatement,
  isStringLiteral as isStringLiteral2,
  traverse as traverse2
} from "@babel/types";
import FS2 from "fs/promises";

// src/meteor/parser/MeteorInstall.ts
import { is, isObjectExpression as isObjectExpression2, traverse } from "@babel/types";

// src/meteor/parser/PackageModule.ts
import {
  isAssignmentExpression,
  isCallExpression,
  isIdentifier,
  isMemberExpression,
  isObjectExpression,
  isObjectProperty,
  isStringLiteral
} from "@babel/types";

// src/meteor/parser/ParserError.ts
import { inspect as inspect2 } from "util";
var ParserError = class extends MeteorViteError {
  constructor(originalMessage, metadata) {
    super(originalMessage);
    this.originalMessage = originalMessage;
    this.metadata = metadata;
  }
  async formatLog() {
    const { parseOptions, node } = await this.metadata || {};
    if (parseOptions?.fileContent) {
      this.addLine([
        `// File content for: ${this.metadata?.parseOptions?.filePath}`,
        ""
      ]);
      (await parseOptions.fileContent).split(/[\r\n]+/).forEach((line) => this.addLine(line));
    }
    if (node) {
      this.addLine([inspect2(node)]);
    }
  }
};
var ModuleExportsError = class extends ParserError {
  constructor(message, node) {
    super(message, { node });
    this.message = message;
    this.node = node;
  }
};

// src/meteor/parser/ParserTypes.ts
var KnownModuleMethodNames = ["export", "link", "exportDefault", "runSetters", "runModuleSetters"];

// src/meteor/parser/PackageModule.ts
var EmittedJsonKeyWarnings = [];
var PackageModule = class {
  constructor(path) {
    this.path = path;
  }
  exports = [];
  jsonContent;
  /**
   * Helper for checking if an already validated node is of the provided method
   */
  isMethod(node, method) {
    return node.callee.property.name === method;
  }
  /**
   * Check if provided node is a valid `module.[method]` call expression.
   */
  isModuleMethodCall(node) {
    if (node.type !== "CallExpression")
      return false;
    const callee = node.callee;
    if (callee.type !== "MemberExpression")
      return false;
    if (callee.object.type !== "Identifier")
      return false;
    if (!callee.object.name.match(/^module\d*$/))
      return false;
    if (callee.property.type !== "Identifier")
      return false;
    const calleeMethod = callee.property.name;
    if (!KnownModuleMethodNames.includes(calleeMethod)) {
      Logger_default.warn(`Meteor module.${calleeMethod}(...) is not recognized by Meteor-Vite! Please open an issue to get this resolved! \u{1F64F}`);
      return false;
    }
    return true;
  }
  getModuleExportsAssignment(node) {
    if (!isAssignmentExpression(node))
      return;
    if (!isMemberExpression(node.left))
      return;
    if (!isIdentifier(node.left.object, { name: "module" }))
      return;
    if (!isIdentifier(node.left.property, { name: "exports" }))
      return;
    return node.right;
  }
  getCjsExportAssignment(node) {
    if (!isAssignmentExpression(node))
      return;
    if (!isMemberExpression(node.left))
      return;
    if (!isIdentifier(node.left.object, { name: "exports" }))
      return;
    if (!isIdentifier(node.left.property))
      return;
    return node.left.property;
  }
  /**
   * Parse everything within the current module and store detected exports.
   * Todo: Possibly migrate parsers to their own class to save on memory usage?
   */
  parse(node) {
    const moduleExports = this.getModuleExportsAssignment(node);
    const cjsExport = this.getCjsExportAssignment(node);
    if (cjsExport) {
      this.exports.push({
        name: cjsExport.name,
        type: "export"
      });
      return;
    }
    if (moduleExports) {
      if (isCallExpression(moduleExports)) {
        if (!isIdentifier(moduleExports.callee, { name: "require" }))
          return;
        if (!isStringLiteral(moduleExports.arguments[0]))
          return;
        if (!this.exports.find(({ as, name }) => (as || name) === "default")) {
          this.exports.push({
            type: "export",
            name: "default"
          });
        }
        this.exports.push({
          type: "re-export",
          from: moduleExports.arguments[0].value,
          name: "*"
        });
        return;
      }
      if (!isObjectExpression(moduleExports)) {
        return;
      }
      if (this.path.endsWith("map.json")) {
        return;
      }
      if (this.path.endsWith("package.json")) {
        this.parseJson(moduleExports);
      }
      this.exports.push(...formatExports({ expression: moduleExports }));
    }
    if (!this.isModuleMethodCall(node))
      return;
    if (this.isMethod(node, "link")) {
      return this.exports.push(...this.parseLink(node));
    }
    if (this.isMethod(node, "export")) {
      return this.exports.push(...this.parseExport(node));
    }
    if (this.isMethod(node, "exportDefault")) {
      this.exports.push(...this.parseExportDefault(node));
      return;
    }
  }
  parseJson(moduleExports) {
    this.jsonContent = {};
    for (const prop of moduleExports.properties) {
      if (!isObjectProperty(prop)) {
        throw new ModuleExportsError("JSON module had an unexpected property export", prop);
      }
      const key = propParser.getKey(prop);
      if (!isStringLiteral(prop.value)) {
        if (EmittedJsonKeyWarnings.includes(key)) {
          return;
        }
        Logger_default.warn(new ModuleExportsError(`Meteor bundle had a package.json key (${key}) with an unexpected value.
This might be important to properly parse the module's entrypoint. Do open a new issue if you run into any issues. \u{1F64F}`, prop));
        EmittedJsonKeyWarnings.push(key);
        return;
      }
      Object.assign(this.jsonContent, { [key]: prop.value.value });
    }
  }
  /**
   * Parse a Meteor bundle's `module.link()` call.
   * {@link ModuleMethod.Link}
   */
  parseLink(node) {
    const [importPath, exports2, id] = node.arguments;
    if (importPath.type !== "StringLiteral") {
      throw new ModuleExportsError("Expected string as the first argument in module.link()!", importPath);
    }
    if (!exports2)
      return [];
    if (exports2.type !== "ObjectExpression") {
      throw new ModuleExportsError(
        "Expected ObjectExpression as the second argument in module.link()!",
        importPath
      );
    }
    if (id?.type !== "NumericLiteral") {
      throw new ModuleExportsError("Expected NumericLiteral as the last argument in module.link()!", importPath);
    }
    return formatExports({
      packageName: importPath,
      expression: exports2,
      id
    });
  }
  /**
   * Parse a Meteor bundle's `module.export({ ... })` call.
   * {@link ModuleMethod.export see type for examples}
   */
  parseExport(node) {
    if (node.arguments[0].type !== "ObjectExpression") {
      throw new ModuleExportsError("Unexpected export type!", exports);
    }
    return formatExports({
      expression: node.arguments[0]
    });
  }
  /**
   * Parse a Meteor bundle's `module.exportDefault()` call.
   * {@link ModuleMethod.exportDefault see examples in type declaration}
   */
  parseExportDefault(node) {
    const args = node.arguments;
    let name = "default";
    if (args[0].type === "Identifier") {
      name = args[0].name;
    } else if (args[0].type === "ConditionalExpression") {
      name = "CONDITIONAL_EXPORT_DEFAULT";
    } else {
      new ModuleExportsError("Unexpected default export value!", args[0]);
    }
    return [{ type: "export-default", name }];
  }
};
function formatExports({ expression, packageName, id }) {
  return expression.properties.map((property) => {
    if (property.type === "SpreadElement")
      throw new ModuleExportsError("Unexpected property type!", property);
    const result = {
      name: propParser.getKey(property),
      type: "export",
      ...id && { id: id.value }
    };
    if (packageName) {
      result.type = "re-export";
      result.from = packageName.value;
    }
    if (result.type === "re-export" && property.type === "ObjectMethod") {
      result.type = "global-binding";
    }
    if (result.type === "re-export" && property.type === "ObjectProperty") {
      const content = property.value;
      if (content.type !== "StringLiteral") {
        throw new ModuleExportsError("Received unsupported result type in re-export!", property);
      }
      if (content.value !== result.name) {
        result.as = content.value;
      }
    }
    return result;
  });
}

// src/meteor/parser/MeteorInstall.ts
var MeteorInstall = class {
  modules = {};
  type;
  packageId;
  name;
  mainModulePath;
  packageJson;
  constructor({ packageId, name, type }) {
    this.packageId = packageId;
    this.name = name;
    this.type = type;
  }
  static parse(node) {
    const atmosphere = this.parseAtmosphereInstall(node);
    const npm = this.parseNpmInstall(node);
    return { npm, atmosphere };
  }
  static parseInstall(node) {
    const [modules, fileExtensions] = node.arguments;
    const node_modules = modules.properties[0];
    if (propParser.getKey(node_modules) !== "node_modules") {
      return {
        type: "unknown"
      };
    }
    const meteor2 = node_modules.value.properties[0];
    if (propParser.getKey(meteor2) === "meteor") {
      return {
        type: "atmosphere",
        meteor: meteor2
      };
    }
    return {
      type: "npm",
      node_modules
    };
  }
  static parseAtmosphereInstall(node) {
    if (!this.isRequireDeclaration(node))
      return;
    if (!this.isMeteorInstall(node.init))
      return;
    const { meteor: meteor2, type } = this.parseInstall(node.init);
    if (type !== "atmosphere" || !meteor2) {
      return;
    }
    const packageName = meteor2.value.properties[0];
    const packageModules = packageName.value.properties;
    const meteorPackage = new this({
      packageId: `${propParser.getKey(meteor2)}/${propParser.getKey(packageName)}`,
      name: propParser.getKey(packageName),
      type: "atmosphere"
    });
    meteorPackage.traverseModules(packageModules, "");
    return meteorPackage;
  }
  static parseNpmInstall(node) {
    if (!this.isMeteorInstall(node))
      return;
    const { node_modules, type } = this.parseInstall(node);
    const npmPackages = [];
    if (type !== "npm" || !node_modules)
      return;
    for (const directory of node_modules.value.properties) {
      if (!isObjectExpression2(directory.value))
        return;
      const npmPackage = new this({
        type: "npm",
        packageId: `${propParser.getKey(directory)}`,
        name: ""
      });
      npmPackage.traverseModules(directory.value.properties, "");
      npmPackages.push(npmPackage);
    }
    return npmPackages;
  }
  static isRequireDeclaration(node) {
    if (node.type !== "VariableDeclarator")
      return false;
    if (node.id.type !== "Identifier")
      return false;
    if (node.id.name !== "require")
      return false;
    return true;
  }
  static isMeteorInstall(expression) {
    if (!expression)
      return false;
    if (expression.type !== "CallExpression")
      return false;
    if (!is("Identifier", expression.callee, { name: "meteorInstall" }))
      return false;
    return true;
  }
  traverseModules(properties, parentPath) {
    properties.forEach((property) => {
      const name = propParser.getKey(property);
      const path = `${parentPath}${name}`;
      const module = new PackageModule(path);
      if (property.value.type === "ObjectExpression") {
        return this.traverseModules(property.value.properties, `${path}/`);
      }
      traverse(property.value.body, {
        enter(node) {
          module.parse(node);
        }
      });
      this.modules[path] = module.exports;
      if (name !== "package.json") {
        return;
      }
      if (this.type !== "npm") {
        return;
      }
      if (!module.jsonContent) {
        throw new ModuleExportsError(`Unable to parse package.json for ${path}!`, property);
      }
      this.packageJson = Object.assign(this.packageJson || {
        name: "",
        version: "",
        main: ""
      }, module.jsonContent);
      this.name = this.name || this.packageJson.name;
      this.packageId = this.packageId || this.packageJson.name;
      this.mainModulePath = this.mainModulePath || this.packageJson.main;
    });
  }
};

// src/meteor/parser/Parser.ts
async function parseMeteorPackage({ fileContent, filePath }) {
  const startTime = Date.now();
  const content = fileContent || FS2.readFile(filePath, "utf-8");
  const result = await parseSource(await content);
  if (!result.name) {
    throw new ParserError(`Could not extract name from package in: ${filePath}`, {
      parseOptions: { fileContent, filePath }
    });
  }
  if (!result.packageId) {
    result.packageId = `meteor/${result.name}`;
  }
  const moduleExports = Object.keys(result.modules);
  const packageExports = Object.keys(result.packageScopeExports);
  if (!moduleExports.length && !packageExports.length) {
    console.warn(
      "Unable to retrieve any metadata from the provided source code!",
      { result }
    );
    throw new ParserError(`No modules or package-scope exports could be extracted from package: ${result.name}`);
  }
  return {
    result,
    timeSpent: `${Date.now() - startTime}ms`
  };
}
function parseSource(code) {
  return new Promise((resolve, reject) => {
    const source = parse(code);
    const result = {
      name: "",
      modules: {},
      packageScopeExports: {},
      mainModulePath: "",
      packageId: "",
      node_modules: []
    };
    traverse2(source, {
      enter(node) {
        const packageScope = parsePackageScope(node);
        const { atmosphere, npm } = MeteorInstall.parse(node);
        result.mainModulePath = readMainModulePath(node) || result.mainModulePath;
        if (atmosphere) {
          Object.assign(result, atmosphere);
        }
        if (npm) {
          result.node_modules?.push(...npm);
        }
        if (packageScope) {
          result.name = result.name || packageScope.name;
          result.packageScopeExports[packageScope.name] = packageScope.exports;
        }
      }
    });
    resolve(result);
  });
}
function readMainModulePath(node) {
  if (node.type !== "VariableDeclarator")
    return;
  if (!is2("Identifier", node.id, { name: "exports" }))
    return;
  if (node.init?.type !== "CallExpression")
    return;
  if (!is2("Identifier", node.init.callee, { name: "require" }))
    return;
  if (node.init.arguments[0]?.type !== "StringLiteral")
    return;
  return node.init.arguments[0].value;
}
function parsePackageScope(node) {
  function meteorV2(node2) {
    if (node2.type !== "CallExpression")
      return;
    if (node2.callee.type !== "MemberExpression")
      return;
    const { object, property } = node2.callee;
    if (object.type !== "Identifier")
      return;
    if (object.name !== "Package")
      return;
    if (property.type !== "Identifier")
      return;
    if (property.name !== "_define")
      return;
    const args = {
      packageName: node2.arguments[0],
      moduleExports: node2.arguments[1],
      packageExports: node2.arguments[2]
    };
    if (args.packageName.type !== "StringLiteral") {
      throw new ModuleExportsError("Unexpected type received for package name!", args.packageName);
    }
    if (!args.packageExports && args.moduleExports?.type === "ObjectExpression") {
      args.packageExports = args.moduleExports;
    }
    const packageExport = {
      name: args.packageName.value,
      exports: []
    };
    if (!args.packageExports) {
      return packageExport;
    }
    if (args.packageExports.type !== "ObjectExpression") {
      throw new ModuleExportsError("Unexpected type received for package-scope exports argument!", args.packageExports);
    }
    args.packageExports.properties.forEach((property2) => {
      if (property2.type === "SpreadElement") {
        throw new ModuleExportsError("Unexpected property type received for package-scope exports!", property2);
      }
      packageExport.exports.push(propParser.getKey(property2));
    });
    return packageExport;
  }
  function meteorV3(node2) {
    if (!isCallExpression2(node2))
      return;
    if (!isMemberExpression2(node2.callee))
      return;
    if (!isIdentifier2(node2.callee.property, { name: "queue" }))
      return;
    if (!isStringLiteral2(node2.arguments[0]))
      return;
    const packageName = node2.arguments[0].value;
    let packageClosure = null;
    const exports2 = [];
    if (isFunctionExpression(node2.arguments[1])) {
      packageClosure = node2.arguments[1];
    }
    if (isFunctionExpression(node2.arguments[2])) {
      packageClosure = node2.arguments[2];
    }
    if (!packageClosure) {
      return;
    }
    for (const node3 of packageClosure.body.body) {
      if (!isReturnStatement(node3))
        continue;
      if (!isObjectExpression3(node3.argument))
        continue;
      for (const property of node3.argument.properties) {
        if (!isObjectProperty2(property))
          continue;
        if (!isIdentifier2(property.key, { name: "export" }))
          continue;
        if (!isFunctionExpression(property.value))
          continue;
        const exportBody = property.value.body.body;
        for (const node4 of exportBody) {
          if (!isReturnStatement(node4))
            continue;
          if (!isObjectExpression3(node4.argument))
            continue;
          node4.argument.properties.forEach((node5) => {
            if (!isObjectProperty2(node5))
              return;
            if (!isIdentifier2(node5.key))
              return;
            exports2.push(node5.key.name);
          });
        }
      }
    }
    return { name: packageName, exports: exports2 };
  }
  return meteorV2(node) || meteorV3(node);
}
var propParser = {
  getKey(property) {
    if (property.key.type === "Identifier") {
      return property.key.name;
    }
    if (property.key.type === "StringLiteral") {
      return property.key.value;
    }
    throw new ModuleExportsError("Unsupported property key type!", property);
  }
};

// src/meteor/package/SerializationStore.ts
import pc5 from "picocolors";

// src/meteor/package/components/ModuleExport.ts
var ModuleExport = class {
  parentModule;
  from;
  as;
  type;
  name;
  id;
  stubType;
  constructor(details) {
    this.parentModule = details.parentModule;
    const { from, as, type, name, id } = details.data;
    this.from = from;
    this.as = as;
    this.name = name;
    this.id = id;
    this.type = type;
    this.stubType = this.determineStubType(type);
  }
  /**
   * Whether this entry needs to be placed at the top of a file, or at the bottom of a file.
   * Just so we don't end up placing `export { foo } from 'meteor/foo:bar'` statements at a place where it can
   * break syntax.
   * // If the placement is 'none', the entry should just be omitted
   *
   * In short, we want re-exports from other modules to be at the top of the file, while normal exports are left
   * at the bottom of the file.
   */
  get placement() {
    if (this.stubType === "re-export") {
      return "top";
    }
    if (this.stubType === "global-binding") {
      return "none";
    }
    return "bottom";
  }
  /**
   * Determine the export type to be used within a stub template for the current export.
   */
  determineStubType(type) {
    if (type === "export") {
      if (this.name === "default") {
        return "export-default";
      }
      return "export";
    }
    if (type === "export-default") {
      return "export-default";
    }
    if (type === "re-export") {
      if (this.name?.trim() === "*") {
        if (!this.as) {
          return "export-all";
        }
        if (this.isReExportedByParent) {
          if (this.as === "default") {
            return "export-default";
          }
          return "export";
        }
        return "re-export";
      }
      if (this.isReExportedByParent) {
        if (this.as === "default") {
          return "export-default";
        }
        return "export";
      }
      return "re-export";
    }
    return type;
  }
  /**
   * The export key for the current entry.
   * Undefined if not applicable.
   *
   * @example
   * export const FooBar = '' // key is FooBar
   * export * from './somewhere' // key is undefined
   * export * as MyModule from './somewhere-else' // key is MyModule
   */
  get key() {
    if (this.name?.trim() === "*") {
      return;
    }
    if (this.type === "export-default") {
      return "default";
    }
    if (this.type === "export") {
      return this.name;
    }
    if (this.type === "re-export") {
      return this.as || this.name;
    }
  }
  /**
   * Full export path for the current export, if it is a re-export
   */
  get exportPath() {
    if (this.type !== "re-export") {
      return;
    }
    if (this.from?.startsWith(".")) {
      return `${this.parentModule.meteorPackage.packageId}/${this.from?.replace(/^[./]+/, "")}`;
    }
    return this.from;
  }
  get isReExportedByParent() {
    if (this.type !== "re-export") {
      return false;
    }
    if (this.from?.startsWith("./")) {
      return true;
    }
    return false;
  }
  /**
   * The current export entry, converted into JavaScript for use as a Meteor stub.
   * Essentially, converting from raw data back into JavaScript.
   */
  serialize({ chainedReExport = false } = {}) {
    switch (this.stubType) {
      case "re-export":
        const key = `${this.name}${this.key && ` as ${this.key}` || ""}`;
        if (chainedReExport) {
          return key;
        }
        return `export { ${key} } from '${this.exportPath}';`;
      case "export":
        return `export const ${this.key} = ${METEOR_STUB_KEY}.${this.key};`;
      case "export-default":
        return `export default ${METEOR_STUB_KEY}.default ?? ${METEOR_STUB_KEY};`;
      case "export-all":
        return `export * from '${this.exportPath}';`;
      case "global-binding":
        return `/* global binding: ${this.name} */`;
    }
    throw new ExportEntrySerializationError(`Unexpected export classification for export: ${this.name} in ${this.parentModule.modulePath}`, { exportEntry: this });
  }
};
var ExportEntrySerializationError = class extends MeteorViteError {
  constructor(message, meta) {
    super(message, meta);
    this.addSection("Cause", meta.exportEntry);
  }
};

// src/meteor/package/components/PackageExport.ts
import pc4 from "picocolors";
var PackageExport = class {
  meteorPackage;
  packageName;
  key;
  constructor({ meteorPackage, key, packageName }) {
    this.meteorPackage = meteorPackage;
    this.packageName = packageName;
    this.key = key;
    if (meteorPackage.name !== packageName) {
      Logger_default.warn(`Detected multiple package definitions within ${pc4.yellow(this.meteorPackage.name)}! Please report this to ${package_default.bugs.url}`);
      Logger_default.warn(`Package ${pc4.red(packageName)} was defined within ${pc4.yellow(meteorPackage.name)} \u{1F914}`);
    }
  }
  serialize() {
    return `export const ${this.key} = ${PACKAGE_SCOPE_KEY}.${this.key};`;
  }
  serializeImport() {
    return `const ${PACKAGE_SCOPE_KEY} = ${TEMPLATE_GLOBAL_KEY}.Package['${this.packageName}']`;
  }
};

// src/meteor/package/SerializationStore.ts
var SerializationStore = class {
  /**
   * Collection of entries that serialize as a normal export.
   * @example input
   * export const foo = 'bar'
   * export { foo as bar } from './foo/bar'
   * export * as foobar from './foo/bar'
   *
   * @example output
   * export const foo = ${METEOR_STUB_KEY}.foo
   * export const bar = ${METEOR_STUB_KEY}.foo
   * export const foobar = ${METEOR_STUB_KEY}.foobar
   */
  exports = /* @__PURE__ */ new Map();
  /**
   * Any export that cannot be serialized using a unique key
   * @example
   * export * from './foo/bar'
   */
  reExportWildcards = /* @__PURE__ */ new Map();
  /**
   * Any named export that originates from another module.
   * @example
   * export * as FooBar from './foo/bar';
   */
  reExports = /* @__PURE__ */ new Map();
  /**
   * Package imports. These do not serialize to ES imports, but rather references to the global Package type where
   * we will simulate a re-export from the given package.
   *
   * @example import
   * const ${PACKAGE_SCOPE_KEY} = ${TEMPLATE_GLOBAL_KEY}.Package['my:package']
   *
   * @example export
   * export const foo = ${PACKAGE_SCOPE_KEY}.foo
   */
  imports = /* @__PURE__ */ new Map();
  /**
   * Re-exports mapped by the path they are exporting from.
   *
   * @example source input
   * export { foo, bar } from 'meteor/foobar'
   * export * as Hello from 'meteor/hello'
   * @example map output
   * ['meteor/foobar', [ModuleExport, ModuleExport]]
   * ['meteor/hello', [ModuleExport]]
   */
  reExportsPathMap = /* @__PURE__ */ new Map();
  constructor() {
  }
  addPackageExport(entry) {
    const existing = this.exports.get(entry.key);
    if (existing) {
      return Logger_default.debug(
        `Discarded submodule entry for package export as there already is an export for it`,
        { existing, entry }
      );
    }
    this.imports.set(entry.packageName, entry);
    this.exports.set(entry.key, entry);
  }
  addEntry(entry) {
    if (entry instanceof PackageExport) {
      return this.addPackageExport(entry);
    }
    if (entry.placement === "none") {
      return;
    }
    if (entry.stubType === "export-all") {
      this.reExportWildcards.set(entry.from, entry);
      return;
    }
    this.validateNewKey(entry);
    if (entry.stubType === "re-export") {
      if (!entry.from)
        throw new ReExportWithoutPath('Detected a re-export entry without a "from" path!', { export: entry });
      const pathMap = this.reExportsPathMap.get(entry.from) || this.reExportsPathMap.set(entry.from, []).get(entry.from);
      this.reExports.set(entry.key, entry);
      pathMap.push(entry);
      return;
    }
    this.exports.set(entry.key, entry);
  }
  validateNewKey(entry) {
    if (!entry.key) {
      throw new MeteorViteError("Unable to determine type for module export!", { cause: entry });
    }
    const existing = this.exports.get(entry.key);
    const existingReExport = this.reExports.get(entry.key);
    if (existing instanceof ModuleExport) {
      throw new ConflictingExportKeys(
        `Duplicate module export detected in ${pc5.yellow(entry.parentModule.meteorPackage.packageId)}!`,
        { conflict: { thisExport: entry, conflictedWith: existing } }
      );
    }
    if (existingReExport) {
      throw new ConflictingExportKeys(
        `Export key is conflicting with a module re-export in ${pc5.yellow(entry.parentModule.meteorPackage.packageId)}!`,
        { conflict: { thisExport: entry, conflictedWith: existingReExport } }
      );
    }
  }
  serialize() {
    const exports2 = /* @__PURE__ */ new Set();
    const reExports = /* @__PURE__ */ new Set();
    const imports = /* @__PURE__ */ new Set();
    this.reExportWildcards.forEach((entry) => reExports.add(entry.serialize()));
    this.reExportsPathMap.forEach((entry, path) => {
      const exportKeys = entry.map((entry2) => entry2.serialize({ chainedReExport: true })).join(", ");
      return reExports.add(`export { ${exportKeys} } from '${path}';`);
    });
    this.imports.forEach((entry) => imports.add(entry.serializeImport()));
    this.exports.forEach((entry) => exports2.add(entry.serialize()));
    return {
      imports: [...imports],
      reExports: [...reExports],
      exports: [...exports2],
      exportKeys: [
        ...this.reExports.keys(),
        ...this.exports.keys()
      ]
    };
  }
};
var ReExportWithoutPath = class extends MeteorViteError {
  constructor(message, meta) {
    super(message, meta);
    this.addSection("Offending export", meta.export);
  }
};
var ConflictingExportKeys = class extends MeteorViteError {
  constructor(message, meta) {
    super(message, meta);
    this.meta = meta;
  }
  async formatLog() {
    const { thisExport, conflictedWith } = this.meta.conflict;
    this.addSection("Conflict", {
      exportKey: thisExport.key
    });
    this.addSection("This export", thisExport);
    this.addSection("Conflicted with", conflictedWith);
  }
};

// src/meteor/package/components/PackageSubmodule.ts
var PackageSubmodule = class {
  /**
   * Relative path from the package name to the module containing these exports.
   * @example
   * 'cookie-store.js'
   */
  modulePath;
  /**
   * ESM exports from the Meteor package module.
   * @example
   * export const foo = '...'
   */
  exports;
  /**
   * The Meteor package this submodule belongs to.
   * @type {MeteorPackage}
   */
  meteorPackage;
  /**
   * Full import path for the package's requested module.
   * @example
   * 'meteor/ostrio:cookies/cookie-store.js'
   */
  get fullImportPath() {
    return `${this.meteorPackage.packageId}${this.modulePath ? `/${this.modulePath}` : ""}`;
  }
  constructor({ meteorPackage, modulePath, exports: exports2 }) {
    this.modulePath = modulePath;
    this.meteorPackage = meteorPackage;
    this.exports = exports2.map((data) => new ModuleExport({ data, parentModule: this }));
  }
};

// src/meteor/package/components/MeteorPackage.ts
var MeteorPackage = class _MeteorPackage {
  constructor(parsedPackage, meta) {
    this.parsedPackage = parsedPackage;
    this.meta = meta;
    this.name = parsedPackage.name;
    this.modules = parsedPackage.modules;
    this.mainModulePath = parsedPackage.mainModulePath;
    this.packageId = parsedPackage.packageId;
    Object.entries(parsedPackage.packageScopeExports).forEach(([packageName, exports2]) => {
      exports2.forEach((key) => {
        this.packageScopeExports.push(new PackageExport({
          packageName,
          meteorPackage: this,
          key
        }));
      });
    });
  }
  name;
  modules;
  mainModulePath;
  packageScopeExports = [];
  packageId;
  toJson() {
    const { name, modules, mainModulePath, packageScopeExports, packageId } = this;
    return JSON.stringify({
      name,
      modules,
      packageScopeExports: packageScopeExports.map(({ packageName, key }) => ({ packageName, key })),
      packageId,
      mainModulePath,
      serialized: {
        mainModule: this.serialize({})
      }
    }, null, 2);
  }
  static async parse(parse2, options) {
    const { result, timeSpent } = await parseMeteorPackage(parse2);
    return new _MeteorPackage(result, { timeSpent, ...options });
  }
  getModule({ importPath }) {
    if (!importPath) {
      return this.mainModule;
    }
    const entries = Object.entries(this.modules);
    const file = entries.find(
      ([fileName, modules]) => isSameModulePath({
        filepathA: importPath,
        filepathB: fileName,
        compareExtensions: false
      })
    );
    if (file) {
      const [modulePath, exports2] = file;
      return new PackageSubmodule({ modulePath, exports: exports2, meteorPackage: this });
    }
    if (!importPath.startsWith("/node_modules/")) {
      throw new MeteorPackageError(`Could not locate module for path: ${importPath}!`, this);
    }
    if (!this.parsedPackage.node_modules) {
      throw new MeteorPackageError(`Unable to retrieve npm packages from Meteor module. (${importPath})`, this);
    }
    const moduleImport = importPath.replace("/node_modules/", "");
    const nodePackage = this.parsedPackage.node_modules.find(({ name }) => {
      if (!name) {
        return;
      }
      if (name === moduleImport) {
        return true;
      }
      if (moduleImport.split("/")[0] === name) {
        return true;
      }
      return false;
    });
    if (!nodePackage) {
      throw new MeteorPackageError(`Could not locate npm package: ${nodePackage} in ${this.name} (${importPath})`, this);
    }
    const meteorNodePackage = new _MeteorPackage({ ...nodePackage, packageScopeExports: {} }, { timeSpent: "none" });
    const childPackageImportPath = moduleImport.replace(nodePackage.name, "").replace(/^\//, "");
    return meteorNodePackage.getModule({ importPath: childPackageImportPath });
  }
  get mainModule() {
    if (!this.mainModulePath) {
      return;
    }
    if (this.mainModulePath in this.modules && this.parsedPackage.type === "npm") {
      return new PackageSubmodule({
        meteorPackage: this,
        modulePath: this.mainModulePath,
        exports: this.modules[this.mainModulePath]
      });
    }
    const [
      node_modules,
      meteor2,
      packageName,
      ...filePath
    ] = this.mainModulePath.replace(/^\/+/g, "").split("/");
    const modulePath = filePath.join("/");
    let exports2 = this.modules[modulePath];
    if (!exports2) {
      Logger_default.warn(new MeteorPackageError(`Could not locate '${this.mainModulePath}' in package!`, this));
      exports2 = [];
    }
    return new PackageSubmodule({
      meteorPackage: this,
      modulePath,
      exports: exports2
    });
  }
  /**
   * Converts all exports parsed for the package into an array of JavaScript stub-related import/export lines.
   */
  serialize({ importPath }) {
    const store = new SerializationStore();
    const submodule = this.getModule({ importPath });
    const addEntry = (entry) => {
      try {
        store.addEntry(entry);
      } catch (error) {
        if (error instanceof ConflictingExportKeys) {
          if (this.meta?.ignoreDuplicateExportsInPackages?.includes(submodule?.meteorPackage.packageId)) {
            return;
          }
        }
        Logger_default.warn(error);
      }
    };
    if (!importPath) {
      this.packageScopeExports.forEach((entry) => addEntry(entry));
    }
    submodule?.exports.forEach((entry) => {
      if (!importPath?.includes("node_modules")) {
        addEntry(entry);
        return;
      }
      if (entry.type !== "re-export" || entry.name !== "*") {
        addEntry(entry);
        return;
      }
      try {
        const module = submodule.meteorPackage.getModule({
          // Todo extract path rewrites like this to a reusable method
          importPath: entry.from?.replace("./", "")
        });
        module.exports.forEach((entry2) => {
          addEntry(entry2);
        });
      } catch (error) {
        Logger_default.warn(error);
      }
    });
    return store.serialize();
  }
};
var REGEX_LEADING_SLASH = /^\/+/;
function isSameModulePath(options) {
  const fileA = Path.parse(options.filepathA.replace(REGEX_LEADING_SLASH, ""));
  const fileB = Path.parse(options.filepathB.replace(REGEX_LEADING_SLASH, ""));
  if (fileA.dir !== fileB.dir) {
    return false;
  }
  if (options.compareExtensions && fileA.ext !== fileB.ext) {
    return false;
  }
  return fileA.name === fileB.name;
}
var MeteorPackageError = class extends MeteorViteError {
  constructor(message, meteorPackage) {
    super(message, { package: meteorPackage });
    this.meteorPackage = meteorPackage;
  }
};

// src/ViteLoadRequest.ts
var ViteLoadRequest = class _ViteLoadRequest {
  constructor(context) {
    this.context = context;
    this.isLazyLoaded = false;
    this.log = createLabelledLogger(`[${pc6.yellow(context.id.replace("meteor/", ""))}]`);
    context.manifest?.resources.forEach((resource) => {
      const isMainModule = resource.fileOptions?.mainModule;
      if (isMainModule) {
        this.mainModulePath = resource.path;
      }
      if (!this.context.file.importPath && isMainModule) {
        this.isLazyLoaded = resource.fileOptions?.lazy || false;
      }
      if (isSameModulePath({
        filepathA: this.context.file.importPath || "",
        filepathB: resource.path,
        compareExtensions: false
      })) {
        this.isLazyLoaded = resource.fileOptions?.lazy || false;
      }
    });
  }
  mainModulePath;
  isLazyLoaded;
  log;
  /**
   * Relative path (for the current package) for the module to yield stubs for.
   *
   * @example formatting
   * this.context.id  // meteor/ostrio:cookies -> index.js (tries to detect mainModule)
   *
   * this.context.id // meteor/ostorio:cookies/some-file -> some-file.js
   * this.context.id // meteor/ostorio:cookies/dir/some-other-file -> dir/some-other-file.js
   */
  get requestedModulePath() {
    if (!this.context.file.importPath) {
      return this.mainModulePath;
    }
    return this.context.file.importPath;
  }
  static resolveId(id) {
    if (id.startsWith("meteor/") || id.startsWith("meteor:")) {
      return `\0${id}`;
    }
  }
  static isStubRequest(id) {
    return id.startsWith("\0meteor/") || id.startsWith("\0meteor:");
  }
  /**
   * Parse an incoming Vite plugin load() request.
   * Builds up the most of the metadata necessary for building up a good Meteor stub template.
   *
   * @param {PreContextRequest} request
   * @return {Promise<ViteLoadRequest>}
   */
  static async prepareContext(request) {
    if (!this.isStubRequest(request.id)) {
      throw new MeteorViteStubRequestError("Tried to set up file context for an unrecognized file path!");
    }
    request.id = this.getStubId(request.id);
    const file = this.loadFileData(request);
    const manifest = await this.loadManifest({ file, ...request });
    return new _ViteLoadRequest({
      file,
      manifest,
      ...request
    });
  }
  /**
   * Slice off the request raw request identifier we use for determining whether to process the request or not.
   *
   * @example
   * '\0meteor/meteor' -> 'meteor/meteor'
   * '\0meteor:react' -> 'meteor/modules/node_modules/react'
   */
  static getStubId(viteId) {
    const importPath = viteId.slice(1);
    if (importPath.startsWith("meteor/")) {
      return importPath;
    }
    return importPath.replace("meteor:", "meteor/modules/node_modules/");
  }
  static loadFileData({ id, pluginSettings: { meteorStubs } }) {
    let {
      /**
       * Base Atmosphere package import This is usually where we find the full package content, even for packages
       * that have multiple entry points.
       * {@link ParsedPackage.packageId}
       */
      packageId,
      /**
       * Requested file path inside the package. (/some-module)
       * Used for packages that have multiple entry points or no mainModule specified in package.js.
       * E.g. `import { Something } from `meteor/ostrio:cookies/some-module`
       * @type {string | undefined}
       */
      importPath
    } = id.match(
      // todo: maybe use the Node.js Path utility?
      /(?<packageId>(meteor\/)[\w\-. ]+(:[\w\-. ]+)?)(?<importPath>\/.+)?/
    )?.groups || {};
    const packageName = packageId.replace(/^meteor\//, "");
    const sourceName = packageName.replace(":", "_");
    const sourceFile = `${sourceName}.js`;
    const sourcePath = Path2.join(meteorStubs.meteor.packagePath, sourceFile);
    const resolverResultCache = JSON.parse(NodeFS.readFileSync(Path2.join(
      meteorStubs.meteor.isopackPath,
      "../resolver-result-cache.json"
    ), "utf-8"));
    const packageVersion = resolverResultCache.lastOutput.answer[packageName];
    const globalMeteorPackagesDir = meteorStubs.meteor.globalMeteorPackagesDir || this.guessMeteorPackagePath();
    const manifestPath = {
      local: Path2.join(meteorStubs.meteor.isopackPath, sourceName, "web.browser.json"),
      globalCache: Path2.join(globalMeteorPackagesDir, sourceName, packageVersion, "web.browser.json")
    };
    const content = FS3.readFile(sourcePath, "utf-8").catch((error) => {
      throw new MeteorViteStubRequestError(`Unable to read file content: ${error.message}`);
    });
    return {
      content,
      packageId,
      importPath,
      sourcePath,
      manifestPath: NodeFS.existsSync(manifestPath.local) ? manifestPath.local : manifestPath.globalCache
    };
  }
  /**
   * Checks Meteor for an Isopack manifest file.
   * We use this to detect whether a module is lazy-loaded and needs to be forcefully imported and for determining
   * the package's entrypoint.
   *
   * @param {FileData} file
   * @return {Promise<ManifestContent>}
   * @protected
   */
  static async loadManifest({ file }) {
    if (!existsSync(file.manifestPath)) {
      return;
    }
    return JSON.parse(await FS3.readFile(file.manifestPath, "utf8"));
  }
  /**
   * Try to determine the path to Meteor's shared package cache.
   * This is used to retrieve isopack metadata for lazy-loaded packages.
   * @return {string}
   * @protected
   */
  static guessMeteorPackagePath() {
    const [root, ...parts] = process.argv0.split(/[\/\\]/);
    let packagePath = root || "/";
    parts.forEach((part) => {
      if (packagePath.includes("/.meteor/packages/meteor-tool")) {
        return;
      }
      packagePath = Path2.posix.join(packagePath, part);
    });
    return Path2.join(packagePath, "../");
  }
  /**
   * Forces an import statement for the current module into the user's Meteor mainModule.
   * Not to be confused with Vite's entrypoint.
   *
   * We do this to work around how Meteor deals with lazy-loaded packages.
   * @return {Promise<void>}
   */
  async forceImport() {
    const mainModule = this.context.pluginSettings.meteorStubs.packageJson.meteor.mainModule;
    const meteorClientEntryFile = Path2.resolve(process.cwd(), mainModule.client);
    if (!existsSync(meteorClientEntryFile)) {
      throw new MeteorViteError(`meteor.mainModule.client file not found: ${meteorClientEntryFile}`);
    }
    await AutoImportQueue_default.write({
      meteorEntrypoint: meteorClientEntryFile,
      importString: this.context.id
    }).catch((error) => {
      if (!(error instanceof RefreshNeeded)) {
        throw error;
      }
      if (!this.context.server) {
        throw error;
      }
      this.context.server.restart(true);
    });
  }
};
var RefreshNeeded = class extends MeteorViteError {
  constructor(message, loadedPackages) {
    super(message);
    this.loadedPackages = loadedPackages;
  }
};
var MeteorViteStubRequestError = class extends MeteorViteError {
};

// src/error/ErrorHandler.ts
function createErrorHandler(fallbackDescription, request) {
  return async (error) => {
    const viteError = await formatError(fallbackDescription, error);
    if (request) {
      viteError.setContext(request);
    }
    if (viteError instanceof RefreshNeeded) {
      return handleRefreshNeeded(viteError);
    }
    await viteError.beautify();
    if (error instanceof FatalMeteorViteError) {
      console.error(error);
      process.exit(1);
    }
    throw error;
  };
}
function formatError(fallbackDescription, error) {
  if (!(error instanceof Error)) {
    return new MeteorViteError("Received an unexpected error format!", { cause: error });
  }
  if (!(error instanceof MeteorViteError)) {
    return new MeteorViteError(fallbackDescription, {
      cause: error
    });
  }
  return error;
}
var lastEmittedWarning = Date.now();
function handleRefreshNeeded(error) {
  if (1e3 < Date.now() - lastEmittedWarning) {
    console.warn(error.message);
    process.emitWarning("Refresh needed!", error.constructor.name);
    lastEmittedWarning = Date.now();
  }
  throw error;
}

// src/plugin/MeteorStubs.ts
var MeteorStubs = setupPlugin(async () => {
  return {
    name: "meteor-vite: stubs",
    resolveId: (id) => ViteLoadRequest.resolveId(id),
    shouldProcess: (viteId) => ViteLoadRequest.isStubRequest(viteId),
    async validateConfig({ meteorStubs }) {
      if (!meteorStubs.packageJson) {
        const jsonPath = meteorStubs.packageJsonPath || "package.json";
        meteorStubs.packageJson = JSON.parse(await FS4.readFile(jsonPath, "utf-8"));
      }
      if (!meteorStubs?.packageJson?.meteor?.mainModule?.client) {
        throw new MeteorViteError(`You need to specify a Meteor entrypoint in your package.json!`, {
          subtitle: `See the following link for more info: ${package_default.homepage}`
        });
      }
    },
    async setupContext(viteId, server, pluginSettings) {
      return ViteLoadRequest.prepareContext({ id: viteId, pluginSettings, server });
    },
    async load(request) {
      const timeStarted = Date.now();
      if (request.isLazyLoaded) {
        await request.forceImport();
      }
      const meteorPackage = await MeteorPackage.parse({
        filePath: request.context.file.sourcePath,
        fileContent: request.context.file.content
      }, {
        ignoreDuplicateExportsInPackages: request.context.pluginSettings.stubValidation.ignoreDuplicateExportsInPackages
      });
      const template = stubTemplate({
        requestId: request.context.id,
        importPath: request.requestedModulePath,
        stubValidation: request.context.pluginSettings.stubValidation,
        meteorPackage
      });
      request.log.debug(`Meteor stub created`, {
        "Parse time": meteorPackage.meta.timeSpent,
        "Request duration": `${Date.now() - timeStarted}ms`
      });
      if (request.context.pluginSettings.meteorStubs.debug) {
        await storeDebugSnippet({ request, stubTemplate: template, meteorPackage });
      }
      return template;
    }
  };
});
async function storeDebugSnippet({ request, stubTemplate: stubTemplate2, meteorPackage }) {
  const baseDir = Path3.join(request.context.pluginSettings.tempDir, "stubs", request.context.file.packageId.replace(":", "_"));
  const templatePath = Path3.join(baseDir, request.context.file.importPath || "", "template.js");
  const packagePath = Path3.join(baseDir, "package.js");
  const parserPath = Path3.join(baseDir, "parsed.json");
  await FS4.mkdir(Path3.dirname(templatePath), { recursive: true });
  await Promise.all([
    FS4.writeFile(templatePath, stubTemplate2),
    FS4.writeFile(packagePath, await request.context.file.content),
    FS4.writeFile(parserPath, meteorPackage.toJson())
  ]);
  request.log.info("Stored debug snippets", {
    File: pc7.cyan(baseDir)
  });
}
function setupPlugin(setup) {
  const handleError = createErrorHandler("Could not set up Vite plugin!");
  const createPlugin = async () => {
    const plugin = await setup();
    let settings;
    let server;
    return {
      name: plugin.name,
      resolveId: plugin.resolveId,
      async configResolved(resolvedConfig) {
        const pluginSettings = resolvedConfig.meteor;
        if (!pluginSettings) {
          throw new MeteorViteError("Unable to get configuration for Meteor-Vite!");
        }
        try {
          settings = pluginSettings;
          await plugin.validateConfig(pluginSettings);
        } catch (error) {
          await handleError(error);
        }
      },
      configureServer(viteDevServer) {
        server = viteDevServer;
      },
      async load(viteId) {
        const shouldProcess = plugin.shouldProcess(viteId);
        if (!shouldProcess) {
          return;
        }
        const request = await plugin.setupContext(viteId, server, settings);
        return plugin.load.apply(this, [request]).catch(
          createErrorHandler("Could not parse Meteor package", request)
        );
      }
    };
  };
  return () => createPlugin().catch(handleError);
}

// src/plugin/ParseConfig.ts
import { mergeConfig } from "vite";
function mergeWithTypes(defaults, overrides) {
  return mergeConfig(defaults, overrides);
}
function parseConfig(config) {
  return config;
}

// src/plugin/Meteor.ts
function meteor(config) {
  return meteorWorker(config);
}
function meteorWorker(config) {
  const METEOR_LOCAL_DIR = process.env.METEOR_LOCAL_DIR || Path4.join(".meteor", "local");
  let enforce;
  let resolveId;
  if (config.externalizeNpmPackages) {
    enforce = "pre";
    resolveId = function resolveId2(id) {
      const [module, ...path] = id.split("/");
      const match = config.externalizeNpmPackages?.find((name) => {
        if (!name)
          return false;
        if (module !== name)
          return false;
        return true;
      });
      if (!match) {
        return;
      }
      return `\0meteor:${id}`;
    };
  }
  return [
    {
      name: "meteor-vite:config",
      enforce,
      resolveId,
      config: (userConfig) => {
        const pluginSettings = mergeMeteorSettings(userConfig, {
          meteorStubs: {
            packageJsonPath: "package.json",
            meteor: {
              packagePath: Path4.join(METEOR_LOCAL_DIR, "build", "programs", "web.browser", "packages"),
              isopackPath: Path4.join(METEOR_LOCAL_DIR, "isopacks")
            }
          },
          tempDir: Path4.join(METEOR_LOCAL_DIR, "vite"),
          stubValidation: {
            warnOnly: process.env.NODE_ENV === "production",
            disabled: false
          }
        }, config);
        const mergedUserConfig = mergeViteSettings(userConfig, {
          optimizeDeps: {
            entries: [pluginSettings.clientEntry]
          }
        });
        userConfig.optimizeDeps = mergedUserConfig.optimizeDeps;
      },
      configResolved(resolvedConfig) {
        const config2 = parseConfig(resolvedConfig);
        if (!config2.meteor) {
          throw new FatalMeteorViteError(
            `Could not retrieve Meteor-Vite settings! Did you forget to add ${pc8.yellow("meteor-vite")} to your Vite config?`,
            {
              subtitle: `See the following link for a setup guide ${package_default.homepage}`
            }
          );
        }
        if (!config2.meteor.clientEntry) {
          throw new FatalMeteorViteError(`You need to specify an entrypoint for Vite!`, {
            subtitle: `More info available here ${package_default.homepage}`
          });
        }
      }
    },
    MeteorStubs()
  ];
}
function mergeMeteorSettings(userConfig, defaults, overrides) {
  const viteConfig = parseConfig(userConfig);
  const existingSettings = viteConfig.meteor || {};
  const withDefaults = mergeWithTypes(defaults, existingSettings);
  return viteConfig.meteor = mergeWithTypes(withDefaults, overrides);
}
function mergeViteSettings(userConfig, defaults) {
  const viteConfig = parseConfig(userConfig);
  return mergeWithTypes(defaults, viteConfig);
}
export {
  meteor
};
//# sourceMappingURL=index.mjs.map