{"version":3,"sources":["../../src/ViteLoadRequest.ts","../../src/error/MeteorViteError.ts","../../src/meteor/package/AutoImportQueue.ts","../../src/utilities/Logger.ts","../../src/meteor/IPC/MeteorEvents.ts","../../src/meteor/package/StubTemplate.ts","../../src/meteor/package/components/MeteorPackage.ts","../../src/meteor/parser/Parser.ts","../../src/meteor/parser/MeteorInstall.ts","../../src/meteor/parser/PackageModule.ts","../../src/meteor/parser/ParserError.ts","../../src/meteor/parser/ParserTypes.ts","../../src/meteor/package/SerializationStore.ts","../../src/meteor/package/components/ModuleExport.ts","../../src/meteor/package/components/PackageExport.ts","../../src/meteor/package/components/PackageSubmodule.ts","../../src/error/ErrorHandler.ts","../../src/meteor/IPC/interface.ts","../../src/meteor/IPC/methods/build.ts","../../src/plugin/Meteor.ts","../../src/plugin/MeteorStubs.ts","../../src/plugin/ParseConfig.ts","../../src/meteor/IPC/methods/vite-server.ts","../../src/meteor/IPC/methods/index.ts","../../src/bin/worker.ts"],"sourcesContent":["import NodeFS, { existsSync } from 'fs';\nimport FS from 'fs/promises';\nimport Path from 'path';\nimport pc from 'picocolors';\nimport { ViteDevServer } from 'vite';\nimport { MeteorViteError } from './error/MeteorViteError';\nimport AutoImportQueue from './meteor/package/AutoImportQueue';\nimport { isSameModulePath } from './meteor/package/components/MeteorPackage';\nimport type { ResolvedPluginSettings } from './VitePluginSettings';\n\nimport { createLabelledLogger, LabelLogger } from './utilities/Logger';\n\nexport default class ViteLoadRequest {\n    \n    public mainModulePath?: string;\n    public isLazyLoaded: boolean;\n    public log: LabelLogger;\n    \n    constructor(public readonly context: RequestContext) {\n        this.isLazyLoaded = false;\n        this.log = createLabelledLogger(`[${pc.yellow(context.id.replace('meteor/', ''))}]`);\n        \n        context.manifest?.resources.forEach((resource) => {\n            const isMainModule = resource.fileOptions?.mainModule;\n            if (isMainModule) {\n                this.mainModulePath = resource.path;\n            }\n            if (!this.context.file.importPath && isMainModule) {\n                this.isLazyLoaded = resource.fileOptions?.lazy || false;\n            }\n            if (isSameModulePath({\n                filepathA: this.context.file.importPath || '',\n                filepathB: resource.path,\n                compareExtensions: false,\n            })) {\n                this.isLazyLoaded = resource.fileOptions?.lazy || false;\n            }\n        });\n    };\n    \n    /**\n     * Relative path (for the current package) for the module to yield stubs for.\n     *\n     * @example formatting\n     * this.context.id  // meteor/ostrio:cookies -> index.js (tries to detect mainModule)\n     *\n     * this.context.id // meteor/ostorio:cookies/some-file -> some-file.js\n     * this.context.id // meteor/ostorio:cookies/dir/some-other-file -> dir/some-other-file.js\n     */\n    public get requestedModulePath() {\n        if (!this.context.file.importPath) {\n            return this.mainModulePath;\n        }\n        \n        return this.context.file.importPath;\n    }\n    \n    public static resolveId(id: string) {\n        if (id.startsWith('meteor/') || id.startsWith('meteor:')) {\n            return `\\0${id}`;\n        }\n    }\n    \n    public static isStubRequest(id: string) {\n        return id.startsWith('\\0meteor/') || id.startsWith('\\0meteor:');\n    }\n    \n    /**\n     * Parse an incoming Vite plugin load() request.\n     * Builds up the most of the metadata necessary for building up a good Meteor stub template.\n     *\n     * @param {PreContextRequest} request\n     * @return {Promise<ViteLoadRequest>}\n     */\n    public static async prepareContext(request: PreContextRequest) {\n        if (!this.isStubRequest(request.id)) {\n            throw new MeteorViteStubRequestError('Tried to set up file context for an unrecognized file path!');\n        }\n        request.id = this.getStubId(request.id);\n        const file = this.loadFileData(request);\n        const manifest = await this.loadManifest({ file, ...request });\n        \n        return new ViteLoadRequest({\n            file,\n            manifest,\n            ...request,\n        });\n    }\n\n    /**\n     * Slice off the request raw request identifier we use for determining whether to process the request or not.\n     *\n     * @example\n     * '\\0meteor/meteor' -> 'meteor/meteor'\n     * '\\0meteor:react' -> 'meteor/modules/node_modules/react'\n     */\n    protected static getStubId(viteId: string) {\n        const importPath = viteId.slice(1);\n        if (importPath.startsWith('meteor/')) {\n            return importPath;\n        }\n        \n        // Todo: Try to cache the meteor/modules package - reading from it can be expensive for larger projects\n        return importPath.replace('meteor:', 'meteor/modules/node_modules/');\n    }\n\n    protected static loadFileData({ id, pluginSettings: { meteorStubs } }: PreContextRequest) {\n        let {\n            /**\n             * Base Atmosphere package import This is usually where we find the full package content, even for packages\n             * that have multiple entry points.\n             * {@link ParsedPackage.packageId}\n             */\n            packageId,\n            \n            /**\n             * Requested file path inside the package. (/some-module)\n             * Used for packages that have multiple entry points or no mainModule specified in package.js.\n             * E.g. `import { Something } from `meteor/ostrio:cookies/some-module`\n             * @type {string | undefined}\n             */\n            importPath,\n        } = id.match( // todo: maybe use the Node.js Path utility?\n            /(?<packageId>(meteor\\/)[\\w\\-. ]+(:[\\w\\-. ]+)?)(?<importPath>\\/.+)?/,\n        )?.groups || {} as { packageId: string, importPath?: string };\n        \n        const packageName = packageId.replace(/^meteor\\//, '');\n        const sourceName = packageName.replace(':', '_');\n        const sourceFile = `${sourceName}.js`;\n        const sourcePath = Path.join(meteorStubs.meteor.packagePath, sourceFile);\n        const resolverResultCache: ResolverResultCache = JSON.parse(NodeFS.readFileSync(Path.join(\n            meteorStubs.meteor.isopackPath,\n            '../resolver-result-cache.json',\n        ), 'utf-8'));\n        const packageVersion = resolverResultCache.lastOutput.answer[packageName];\n        const globalMeteorPackagesDir = meteorStubs.meteor.globalMeteorPackagesDir || this.guessMeteorPackagePath();\n        \n        const manifestPath = {\n            local: Path.join(meteorStubs.meteor.isopackPath, sourceName, 'web.browser.json'),\n            globalCache: Path.join(globalMeteorPackagesDir, sourceName, packageVersion, 'web.browser.json'),\n        };\n        \n        /**\n         * Raw file content for the current file request.\n         * We don't want to await it here to keep things snappy until the content is actually needed.\n         *\n         * @type {Promise<string>}\n         */\n        const content = FS.readFile(sourcePath, 'utf-8').catch((error: Error) => {\n            throw new MeteorViteStubRequestError(`Unable to read file content: ${error.message}`);\n        });\n        \n        return {\n            content,\n            packageId,\n            importPath,\n            sourcePath,\n            manifestPath: NodeFS.existsSync(manifestPath.local)\n                          ? manifestPath.local\n                          : manifestPath.globalCache,\n        };\n    }\n    \n    /**\n     * Checks Meteor for an Isopack manifest file.\n     * We use this to detect whether a module is lazy-loaded and needs to be forcefully imported and for determining\n     * the package's entrypoint.\n     *\n     * @param {FileData} file\n     * @return {Promise<ManifestContent>}\n     * @protected\n     */\n    protected static async loadManifest({ file }: PreContextRequest & { file: FileData }) {\n        if (!existsSync(file.manifestPath)) {\n            return;\n        }\n        \n        return JSON.parse(await FS.readFile(file.manifestPath, 'utf8')) as ManifestContent;\n    }\n    \n    /**\n     * Try to determine the path to Meteor's shared package cache.\n     * This is used to retrieve isopack metadata for lazy-loaded packages.\n     * @return {string}\n     * @protected\n     */\n    protected static guessMeteorPackagePath() {\n        const [root, ...parts] = process.argv0.split(/[\\/\\\\]/);\n        let packagePath = root || '/';\n        \n        parts.forEach((part) => {\n            if (packagePath.includes('/.meteor/packages/meteor-tool')) {\n                return;\n            }\n            packagePath = Path.posix.join(packagePath, part);\n        });\n        \n        return Path.join(packagePath, '../');\n    }\n    \n    /**\n     * Forces an import statement for the current module into the user's Meteor mainModule.\n     * Not to be confused with Vite's entrypoint.\n     *\n     * We do this to work around how Meteor deals with lazy-loaded packages.\n     * @return {Promise<void>}\n     */\n    public async forceImport() {\n        const mainModule = this.context.pluginSettings.meteorStubs.packageJson!.meteor.mainModule;\n        const meteorClientEntryFile = Path.resolve(process.cwd(), mainModule.client);\n        \n        if (!existsSync(meteorClientEntryFile)) {\n            throw new MeteorViteError(`meteor.mainModule.client file not found: ${meteorClientEntryFile}`);\n        }\n        \n        await AutoImportQueue.write({\n            meteorEntrypoint: meteorClientEntryFile,\n            importString: this.context.id,\n        }).catch((error) => {\n            if (!(error instanceof RefreshNeeded)) {\n                throw error;\n            }\n            if (!this.context.server) {\n                throw error;\n            }\n            \n            this.context.server.restart(true);\n        });\n    }\n    \n}\n\n\n/**\n * Load request file metadata. See linked method for documentation for the associated properties.\n * {@link ViteLoadRequest.loadFileData}\n */\nexport type FileRequestData = ReturnType<typeof ViteLoadRequest['loadFileData']>\n\ninterface PreContextRequest {\n    id: string;\n    pluginSettings: ResolvedPluginSettings;\n    server: ViteDevServer;\n}\n\nexport interface RequestContext extends PreContextRequest {\n    manifest?: ManifestContent;\n    file: FileData;\n}\n\ntype FileData = ReturnType<typeof ViteLoadRequest['loadFileData']>;\n\ninterface ManifestContent {\n    format: string;\n    declaredExports: [];\n    uses: { 'package': string }[];\n    resources: ManifestResource[];\n}\n\ninterface ManifestResource {\n    path: string;\n    fileOptions?: { lazy: boolean; mainModule: boolean };\n    extension: string;\n    file: string;\n    offset: number;\n    length: number;\n    type: string;\n    hash: string;\n}\n\ntype VersionString = `${string}.${string}.${string}`;\n\ninterface ResolverResultCache {\n    lastInput: {\n        dependencies: string[],\n        constraints: `${string}@${VersionString}`[],\n        previousSolution: Record<string, VersionString>;\n    },\n    lastOutput: {\n        neededToUseUnanticipatedPrereleases: boolean;\n        answer: Record<string, VersionString>;\n    }\n    \n}\n\nexport class RefreshNeeded extends MeteorViteError {\n    constructor(message: string, public readonly loadedPackages: string[]) {\n        super(message);\n    }\n}\n\nclass MeteorViteStubRequestError extends MeteorViteError {\n}\n","import { inspect } from 'util';\nimport MeteorPackage from '../meteor/package/components/MeteorPackage';\nimport ViteLoadRequest, { RequestContext } from '../ViteLoadRequest';\nimport PackageJson from '../../package.json';\nimport pc from 'picocolors';\n\nconst divColor = (text: string) => pc.dim(text);\n\nexport class MeteorViteError extends Error implements ErrorMetadata {\n    public package: ErrorMetadata['package'];\n    public context: ErrorMetadata['context'];\n    public cause: ErrorMetadata['cause'];\n    public subtitle?: ErrorMetadata['subtitle'];\n    protected metadataLines: string[] = [];\n    \n    constructor(public originalMessage?: string, { cause, context, package: meteorPackage, subtitle }: ErrorMetadata = {}) {\n        super(originalMessage);\n        this.subtitle = subtitle\n        this.cause = cause;\n        this.context = context;\n        this.package = meteorPackage;\n        \n        if (cause instanceof Error && !subtitle) {\n            this.subtitle = `Caused by [${cause?.name}] ${cause?.message}`\n        }\n        if (cause) {\n            this.addSection('Caused by', cause);\n        }\n    }\n    \n    protected addLine(...lines: string[] | [string[]]) {\n        if (Array.isArray(lines[0])) {\n            lines = lines[0];\n        }\n        const whitespace = '  '\n        this.metadataLines.push(`${whitespace}${lines.join(whitespace)}`);\n    }\n    \n    public setContext(loadRequest: ViteLoadRequest) {\n        this.context = loadRequest.context;\n    }\n    \n    protected async formatLog() {\n        // Used for errors that extend MeteorViteError to add additional data to the error's stack trace.\n    }\n    \n    protected addSection(title: string, object: any) {\n        const content = inspect(object, { colors: true });\n        const divider = this.titleDivider({\n            title: `[${title}]`,\n            indent: 2,\n        })\n        this.addLine(divider);\n        content.split(/[\\r\\n]+/).forEach((line) => {\n            this.addLine(`${divColor('|')}  ${line}`)\n        })\n    }\n    \n    protected titleDivider({\n       title = '',\n       addLength = 0,\n       divider = '-',\n       indent = 0\n   }) {\n        divider = divColor(divider);\n        let repeatCount = 85 - title.length + addLength - indent;\n        if (repeatCount < 1) {\n            return title;\n        }\n        return `${divider.repeat(indent)}${title}${divider.repeat(repeatCount)}`\n    }\n    \n    public async beautify() {\n        await this.formatLog();\n        \n        const moduleId = this.context?.id.replace('meteor/', '') || this.package?.packageId;\n        const moduleString = moduleId && pc.yellow(`\\nâš¡   <${moduleId}>`) || '';\n        this.name = `\\n\\n${this.titleDivider({\n            title: `[${this.constructor.name}]`,\n            divider: '_',\n            indent: 6,\n        })}${moduleString}`;\n        \n        this.message = [\n            '',\n            '',\n            `${pc.bgRed(pc.bold(' ERROR '))} ${this.message}`,\n            `${pc.dim(this.subtitle)}`,\n            '',\n            ...this.metadataLines!,\n            this.titleDivider({\n                title: '[Error Stack]',\n                indent: 2,\n            }),\n        ].filter((line, index) => {\n            if (typeof line !== 'string') {\n                return false;\n            }\n            if (index === 1 && !this.subtitle) { // Filter out subtitle\n                return false;\n            }\n            return true;\n        }).join('\\n');\n        \n        const endOfLog = this.titleDivider({ divider: '_' })\n        const reportIssue = ` ðŸ›  Report an issue:\\n  -  ${PackageJson.bugs.url}`\n        this.stack = `${this.stack}\\n\\n${reportIssue}\\n${endOfLog}\\n`;\n        \n        if (!this.cause) {\n            this.clearProperties(['cause'])\n        }\n        \n        this.clearProperties([\n            'subtitle',\n            'originalMessage',\n            'package',\n            'context',\n            'metadataLines',\n        ])\n    }\n    \n    protected clearProperties(keys: (keyof ErrorMetadata | keyof MeteorViteError | 'metadataLines')[]) {\n        keys.forEach((key) => delete this[key]);\n    }\n}\n\nexport class FatalMeteorViteError extends MeteorViteError {}\n\nexport interface ErrorMetadata {\n    subtitle?: string;\n    package?: Pick<MeteorPackage, 'packageId'>;\n    context?: Pick<RequestContext, 'id'>;\n    cause?: Error | unknown;\n}","import FS from 'fs/promises';\nimport pc from 'picocolors';\nimport Logger from '../../utilities/Logger';\nimport { RefreshNeeded } from '../../ViteLoadRequest';\nimport MeteorEvents, { EventTimeout } from '../IPC/MeteorEvents';\nimport { viteAutoImportBlock } from './StubTemplate';\nimport PLimit from 'p-limit';\n\nexport const wait = (waitMs: number) => new Promise<void>((resolve) => setTimeout(() => resolve(), waitMs));\n\nclass AutoImportQueue {\n    protected restartTimeout?: ReturnType<typeof setTimeout>;\n    protected addedPackages: string[] = [];\n    protected queueWrite = PLimit(1);\n    protected onRestartWatchers: (() => void)[] = [];\n    \n    /**\n     * Once an import is added for a lazy-loaded package, the Meteor server needs to restart in order for the\n     * package to become available to Vite.\n     *\n     * This countdown timer will start from the first auto-import and reset with every following import request\n     * within the time limit. If no more requests are received, the server will finally restart.\n     * @type {number}\n     */\n    public readonly RESTART_COUNTDOWN_MS = 2_500;\n    \n    /**\n     * Queues auto-imports for writing to disk to avoid race-conditions with concurrent write requests to the same file.\n     */\n    public async write({ importString, meteorEntrypoint, skipRestart }: {\n        meteorEntrypoint: string;\n        importString: string;\n        skipRestart?: boolean; // Skip restart when module is added to Meteor entrypoint\n    }) {\n        const lastPackageCount = this.addedPackages.length;\n        const content = await FS.readFile(meteorEntrypoint, 'utf-8');\n        \n        if (content.includes(`'${importString}'`)) {\n            Logger.debug('Skipping auto-import for \"%s\" as it already has all the necessary imports', importString);\n            return;\n        }\n        \n        await this.queueWrite(async () => {\n            const content = await FS.readFile(meteorEntrypoint, 'utf-8')\n            const newContent = viteAutoImportBlock({\n                id: importString,\n                content,\n            });\n            \n            await FS.writeFile(meteorEntrypoint, newContent);\n            this.addedPackages.push(importString);\n            const logMessage = skipRestart\n                               ? 'Added auto-import for \"%s\" - you may need to refresh your client manually'\n                               : 'Added auto-import for \"%s\" - waiting for Meteor to refresh the client';\n            \n            Logger.info(logMessage, importString);\n        })\n        \n        if (this.addedPackages.length > lastPackageCount && !skipRestart) {\n            await MeteorEvents.waitForMessage({\n                topic: ['webapp-reload-client', 'client-refresh'],\n                timeoutMs: process.env.NODE_ENV === 'test' ? 50 : 15_000, // todo: implement tests for this\n            }).catch((error: Error) => {\n                if (error instanceof EventTimeout) {\n                    Logger.warn(`Timed out waiting for Meteor to refresh the client for ${pc.yellow(importString)}!`)\n                    return this.scheduleRestart()\n                }\n                throw error\n            })\n        }\n    }\n    \n    protected scheduleRestart() {\n        if (this.restartTimeout) {\n            clearTimeout(this.restartTimeout);\n        }\n        \n        this.restartTimeout = setTimeout(() => {\n            this.onRestartWatchers.forEach((callListener) => callListener());\n        }, this.RESTART_COUNTDOWN_MS)\n        \n        return new Promise<void>((resolve, reject) => {\n            this.onRestartWatchers.push(() => {\n                reject(\n                    new RefreshNeeded(`Terminating Vite server to load isopacks for new packages`, this.addedPackages)\n                )\n            })\n        })\n    }\n}\n\nconst AutoImportQueueInstance = new AutoImportQueue();\n\nexport default AutoImportQueueInstance;","import pc from 'picocolors';\nimport { MeteorViteError } from '../error/MeteorViteError';\n\nfunction createLogger<Params extends DefaultParams>(formatter: (...params: Params) => DefaultParams): LoggerObject<Params> {\n    return {\n        info: (...params: Params) => console.log(...formatMessage(formatter(...params))),\n        warn: (...params: Params) => console.warn(...formatMessage(formatter(...params))),\n        error: (...params: Params) => console.error(...formatMessage(formatter(...params))),\n        debug: (...params: Params) => process.env.ENABLE_DEBUG_LOGS && console.debug(...formatMessage(formatter(...params))),\n    }\n}\n\nfunction formatMessage([message, ...params]: Parameters<typeof console.log>): Parameters<typeof console.log> {\n    if (message instanceof MeteorViteError) {\n        message.beautify().then(() => console.warn(message, ...params));\n        return [];\n    }\n    if (typeof message === 'string') {\n        return [`âš¡  ${message}`, ...params];\n    }\n    return [message, ...params];\n}\nexport type LoggerObject<Params extends DefaultParams> = { [key in LoggerMethods]: (...params: Params) => void };\ntype DefaultParams = Parameters<typeof console.log>;\ntype LoggerMethods = 'info' | 'warn' | 'error' | 'debug';\n\nexport const createLabelledLogger = (label: string) => createLogger((message: string, dataLines: [key: string, value: string][] | Record<string, string>) => {\n    if (!Array.isArray(dataLines)) {\n        dataLines = Object.entries(dataLines);\n    }\n    const data = dataLines.map(([key, value]) => {\n        return `\\n ${pc.dim('L')}  ${key}: ${value}`\n    }).join('')\n    \n    return [`${label} ${message}${data}`]\n});\n\nexport type LabelLogger = ReturnType<typeof createLabelledLogger>\n\nexport default createLogger((...params: DefaultParams) => params);\n","import { EventEmitter } from 'events';\nimport Logger from '../../utilities/Logger';\n\ntype MeteorIPCTopic = 'webapp-reload-client' | 'webapp-pause-client' | 'client-refresh';\n\nexport type MeteorIPCMessage = {\n    type: 'METEOR_IPC_MESSAGE',\n    responseId: string,\n    topic: MeteorIPCTopic,\n    encodedPayload: string\n}\n\nclass MeteorEventBus {\n    protected readonly events = new EventEmitter();\n    \n    /**\n     * Wait for one of the provided IPC message topics before resolving the promise.\n     *\n     * @param {{topics: MeteorIPCTopic[], timeoutMs: number}} event\n     * @returns {Promise<void>}\n     */\n    public waitForMessage(event: {\n        /**\n         * Meteor IPC event name.\n         * E.g. webapp-reload-client, client-refresh\n         */\n        topic: MeteorIPCTopic[],\n        \n        /**\n         * How long to wait before rejecting the promise.\n         * Useful to prevent a promise from hanging indefinitely.\n         */\n        timeoutMs: number\n    }) {\n        const awaitedEvents = event.topic.map((topic) => awaitEvent({\n            emitter: this.events,\n            name: topic,\n            timeoutMs: event.timeoutMs,\n        }));\n        \n        return Promise.race(awaitedEvents);\n    }\n    \n    public ingest(message: MeteorIPCMessage) {\n        Logger.debug('Received Meteor IPC message:', message);\n        this.events.emit(message.topic);\n    }\n}\n\n\nfunction awaitEvent<\n    Emitter extends EventEmitter,\n    EventParams extends Parameters<Emitter['once']>,\n    ListenerArgs extends Parameters<EventParams[1]>\n>(event: {\n    name: EventParams[0];\n    emitter: Emitter;\n    timeoutMs: number;\n}) {\n    return new Promise<ListenerArgs>((_resolve, _reject) => {\n        let rejected = false;\n        let resolved = false;\n        \n        const listener = (data: ListenerArgs) => {\n            resolve(data);\n        }\n        \n        const reject = (error: Error) => {\n            if (resolved || rejected) return;\n            rejected = true;\n            event.emitter.removeListener(event.name, listener);\n            \n            _reject(error);\n        }\n        \n        const resolve = (data: ListenerArgs) => {\n            if (resolved || rejected) return;\n            resolved = true;\n            \n            _resolve(data);\n        }\n        \n        event.emitter.once(event.name, listener);\n        setTimeout(() => reject(new EventTimeout(`Timed out waiting for event: ${String(event.name)}`)), event.timeoutMs);\n    })\n}\n\nconst MeteorEvents = new MeteorEventBus();\n\nexport class EventTimeout extends Error {}\nexport default MeteorEvents;\n","import { StubValidatorOptions } from '../../client/ValidateStub';\nimport type { StubValidationSettings } from '../../VitePluginSettings';\n\nimport MeteorPackage from './components/MeteorPackage';\n\nexport const METEOR_STUB_KEY = `m2`;\nexport const PACKAGE_SCOPE_KEY = 'm';\nexport const TEMPLATE_GLOBAL_KEY = 'g';\n\n/**\n * Creates a stub for the provided Meteor package and requested submodule.\n * Used to bridge imports for Meteor code that Vite doesn't have access to, to the below template that acts as a\n * proxy between Vite and Meteor's modules.\n */\nexport function stubTemplate({ requestId, meteorPackage, importPath, stubValidation: validationSettings }: {\n    requestId: string;\n    stubValidation?: StubValidationSettings,\n    meteorPackage: MeteorPackage;\n    importPath?: string;\n}) {\n    const stubId = getStubId();\n    const { packageId } = meteorPackage;\n    const submodule = meteorPackage.getModule({ importPath });\n    const serializedPackage = meteorPackage.serialize({ importPath });\n    const fullImportPath = submodule?.fullImportPath || packageId;\n    \n    const stubValidation = stubValidationTemplate({\n        packageId,\n        requestId,\n        settings: validationSettings,\n        exportKeys: serializedPackage.exportKeys,\n    });\n    \n    // language=\"js\"\n    return`\n// requestId: ${requestId}\n// packageId: ${packageId}\n\n${stubValidation.importString}\nconst ${TEMPLATE_GLOBAL_KEY} = typeof window !== 'undefined' ? window : global;\n${serializedPackage.imports.join('\\n')}\n${serializedPackage.reExports.join('\\n')}\n\nlet ${METEOR_STUB_KEY};\nconst require = Package.modules.meteorInstall({\n  '__vite_stub${stubId}.js': (require, exports, module) => {\n      ${METEOR_STUB_KEY} = require('${fullImportPath}');\n      \n      ${stubValidation.validateStub}\n  }\n}, {\n  \"extensions\": [\n    \".js\"\n  ]\n})\nrequire('/__vite_stub${stubId}.js')\n\n${serializedPackage.exports.join('\\n')}\n`\n}\n\n/**\n * Find the vite:bundler auto-import notice block to add more imports within it.\n *\n * {@link https://regex101.com/r/shKDPE/1}\n * @type {RegExp}\n */\nconst REGEX_AUTO_IMPORT_BLOCK = /(?<startBlock>\\*\\*\\/[\\r\\n\\s]+)(?<imports>(?:.*[\\r\\n])*)(?<endBlock>[\\s\\r\\n]*\\/\\*\\* End of vite[\\-:]bundler auto-imports \\*\\*\\/)/\n\nexport function viteAutoImportBlock({ content, id }: { content: string, id: string }) {\n    let { startBlock, imports, endBlock } = content.match(REGEX_AUTO_IMPORT_BLOCK)?.groups || { imports: '' };\n    \n    imports += `import '${id}';\\n`;\n    imports = imports.trim();\n    \n    if (endBlock && startBlock) {\n        return content.replace(REGEX_AUTO_IMPORT_BLOCK, `${startBlock.trim()}\\n${imports}\\n${endBlock.trim()}`);\n    }\n    \n    return `/**\n * These modules are automatically imported by jorgenvatle:vite-bundler.\n * You can commit these to your project or move them elsewhere if you'd like,\n * but they must be imported somewhere in your Meteor entrypoint file.\n *\n * More info: https://github.com/JorgenVatle/meteor-vite#lazy-loaded-meteor-packages\n**/\n${imports}\n/** End of vite-bundler auto-imports **/\n\n${content}`;\n}\n\nfunction stubValidationTemplate({ settings, requestId, exportKeys, packageId }: {\n    settings?: StubValidationSettings,\n    requestId: string;\n    exportKeys: string[];\n    packageId: string;\n}) {\n    if (settings?.disabled) {\n        return {\n            importString: '',\n            validateStub: '',\n        };\n    }\n    \n    if (settings?.ignorePackages?.includes(packageId)) {\n        return {\n            importString: '',\n            // language=js\n            validateStub: `console.debug(\"Stub validation disabled for '${packageId}'\");`,\n        }\n    }\n    \n    const validatorOptions: StubValidatorOptions = {\n        requestId,\n        packageName: packageId,\n        exportKeys: exportKeys,\n        warnOnly: settings?.warnOnly,\n    }\n    \n    // language=js\n    const importString = `import { validateStub } from 'meteor-vite/client';`\n    // language=js\n    const validateStub = `validateStub(${METEOR_STUB_KEY}, ${JSON.stringify(validatorOptions)});`;\n    \n    return {\n        importString,\n        validateStub,\n    }\n}\n\n/**\n * Unique ID for the next stub.\n * @type {number}\n */\nlet nextStubId = 0;\nfunction getStubId() {\n    return nextStubId++;\n}\n","import Path from 'path';\nimport { MeteorViteError } from '../../../error/MeteorViteError';\nimport Logger from '../../../utilities/Logger';\nimport type { ModuleList, ParsedPackage } from '../../parser/Parser';\nimport { parseMeteorPackage } from '../../parser/Parser';\nimport { ConflictingExportKeys, SerializationStore } from '../SerializationStore';\nimport type ModuleExport from './ModuleExport';\nimport PackageExport from './PackageExport';\nimport { PackageSubmodule } from './PackageSubmodule';\n\nexport default class MeteorPackage implements Omit<ParsedPackage, 'packageScopeExports'> {\n    \n    public readonly name: string;\n    public readonly modules: ModuleList;\n    public readonly mainModulePath?: string;\n    public readonly packageScopeExports: PackageExport[] = [];\n    public readonly packageId: string;\n    \n    constructor(public readonly parsedPackage: ParsedPackage, public readonly meta: { timeSpent: string; ignoreDuplicateExportsInPackages?: string[] }) {\n        this.name = parsedPackage.name;\n        this.modules = parsedPackage.modules;\n        this.mainModulePath = parsedPackage.mainModulePath;\n        this.packageId = parsedPackage.packageId;\n        \n        Object.entries(parsedPackage.packageScopeExports).forEach(([packageName, exports]) => {\n            exports.forEach((key) => {\n                this.packageScopeExports.push(new PackageExport({\n                    packageName,\n                    meteorPackage: this,\n                    key,\n                }));\n            });\n        })\n    }\n    \n    public toJson() {\n        const { name, modules, mainModulePath, packageScopeExports, packageId } = this;\n        return JSON.stringify({\n            name,\n            modules,\n            packageScopeExports: packageScopeExports.map(({ packageName, key }) => ({ packageName, key })),\n            packageId,\n            mainModulePath,\n            serialized: {\n                mainModule: this.serialize({}),\n            }\n        }, null, 2);\n    }\n    \n    public static async parse(parse: Parameters<typeof parseMeteorPackage>[0], options?: { ignoreDuplicateExportsInPackages?: string[] }) {\n        const { result, timeSpent } = await parseMeteorPackage(parse);\n        return new MeteorPackage(result, { timeSpent, ...options });\n    }\n    \n    public getModule({ importPath }: { importPath?: string }): PackageSubmodule | undefined {\n        if (!importPath) {\n            return this.mainModule;\n        }\n        \n        \n        const entries = Object.entries(this.modules);\n        const file = entries.find(\n            ([fileName, modules]) => isSameModulePath({\n                filepathA: importPath,\n                filepathB: fileName,\n                compareExtensions: false,\n            }),\n        );\n        \n        if (file) {\n            const [modulePath, exports] = file;\n            \n            return new PackageSubmodule({ modulePath, exports, meteorPackage: this });\n        }\n        \n        if (!importPath.startsWith('/node_modules/')) {\n            throw new MeteorPackageError(`Could not locate module for path: ${importPath}!`, this);\n        }\n        \n        if (!this.parsedPackage.node_modules) {\n            throw new MeteorPackageError(`Unable to retrieve npm packages from Meteor module. (${importPath})`, this);\n        }\n        \n        const moduleImport = importPath.replace('/node_modules/', '');\n        const nodePackage = this.parsedPackage.node_modules.find(({ name }) => {\n            if (!name) {\n                return;\n            }\n            if (name === moduleImport) {\n                return true;\n            }\n            if (moduleImport.split('/')[0] === name) {\n                return true;\n            }\n            return false;\n        });\n        \n        if (!nodePackage) {\n            throw new MeteorPackageError(`Could not locate npm package: ${nodePackage} in ${this.name} (${importPath})`, this);\n        }\n        \n        const meteorNodePackage = new MeteorPackage({ ...nodePackage, packageScopeExports: {} }, { timeSpent: 'none' });\n        const childPackageImportPath = moduleImport.replace(nodePackage.name, '').replace(/^\\//, '');\n        return meteorNodePackage.getModule({ importPath: childPackageImportPath });\n    }\n    \n    public get mainModule(): PackageSubmodule | undefined {\n        if (!this.mainModulePath) {\n            return;\n        }\n        \n        if (this.mainModulePath in this.modules && this.parsedPackage.type === 'npm') {\n            return new PackageSubmodule({\n                meteorPackage: this,\n                modulePath: this.mainModulePath,\n                exports: this.modules[this.mainModulePath]\n            })\n        }\n        \n        const [\n            node_modules,\n            meteor,\n            packageName,\n            ...filePath\n        ] = this.mainModulePath.replace(/^\\/+/g, '').split('/');\n        \n        const modulePath = filePath.join('/');\n        let exports = this.modules[modulePath];\n        \n        if (!exports) {\n             Logger.warn(new MeteorPackageError(`Could not locate '${this.mainModulePath}' in package!`, this));\n             exports = []\n        }\n        \n        return new PackageSubmodule({\n            meteorPackage: this,\n            modulePath,\n            exports,\n        });\n    }\n    \n    \n    /**\n     * Converts all exports parsed for the package into an array of JavaScript stub-related import/export lines.\n     */\n    public serialize({ importPath }: { importPath?: string }) {\n        const store = new SerializationStore();\n        const submodule = this.getModule({ importPath });\n        \n        const addEntry = (entry: ModuleExport | PackageExport) => {\n            try {\n                store.addEntry(entry);\n            } catch (error) {\n                if (error instanceof ConflictingExportKeys) {\n                    if (this.meta?.ignoreDuplicateExportsInPackages?.includes(submodule?.meteorPackage.packageId!)) {\n                        return;\n                    }\n                }\n                Logger.warn(error);\n            }\n        }\n        \n        // Package exports are only available at the package's mainModule, so if an import path is provided,\n        // we want to omit any of these exports and only use the module-specific exports\n        if (!importPath) {\n            this.packageScopeExports.forEach((entry) => addEntry(entry));\n        }\n        \n        submodule?.exports.forEach((entry) => {\n            if (!importPath?.includes('node_modules')) {\n                addEntry(entry);\n                return;\n            }\n            \n            if (entry.type !== 're-export' || entry.name !== '*') {\n                addEntry(entry);\n                return;\n            }\n            \n            /** Flatten re-exports for relative modules.\n             * @example root module\n             * // index.js\n             * export * from './cjs/react.production.min.js'\n             *\n             * @example stub output\n             * export const useState = ...\n             * export const createContext = ...\n             */\n            try {\n                const module = submodule.meteorPackage.getModule({\n                    // Todo extract path rewrites like this to a reusable method\n                    importPath: entry.from?.replace('./', '')\n                });\n                module!.exports.forEach((entry) => {\n                    addEntry(entry)\n                });\n            } catch (error) {\n                Logger.warn(error);\n            }\n        });\n        \n        return store.serialize();\n    }\n}\n\n/**\n * Check if the two provided module paths are the same.\n * Todo: this may end up causing issues if a package has say a \"myModule.ts\" and a \"myModule.ts\" file.\n */\nconst REGEX_LEADING_SLASH = /^\\/+/;\n\nexport function isSameModulePath(options: {\n    filepathA: string,\n    filepathB: string,\n    compareExtensions: boolean;\n}) {\n    const fileA = Path.parse(options.filepathA.replace(REGEX_LEADING_SLASH, ''));\n    const fileB = Path.parse(options.filepathB.replace(REGEX_LEADING_SLASH, ''));\n    \n    if (fileA.dir !== fileB.dir) {\n        return false;\n    }\n    \n    if (options.compareExtensions && fileA.ext !== fileB.ext) {\n        return false;\n    }\n    \n    return fileA.name === fileB.name;\n}\n\nclass MeteorPackageError extends MeteorViteError {\n    constructor(message: string, public readonly meteorPackage: MeteorPackage) {\n        super(message, { package: meteorPackage });\n    }\n}","import { parse } from '@babel/parser';\nimport {\n    type FunctionExpression,\n    is,\n    isCallExpression,\n    isFunctionExpression,\n    isIdentifier,\n    isMemberExpression,\n    isObjectExpression,\n    isObjectProperty,\n    isReturnStatement,\n    isStringLiteral,\n    Node,\n    ObjectMethod,\n    ObjectProperty,\n    traverse,\n} from '@babel/types';\nimport FS from 'fs/promises';\nimport { MeteorInstall } from './MeteorInstall';\nimport { ModuleExportsError, ParserError } from './ParserError';\n\nexport interface ParseOptions {\n    /**\n     * Absolute file path to the package's JavaScript file.\n     * This file needs to have been built by Meteor.\n     * The package source code is not handled by the parser.\n     */\n    filePath: string;\n    \n    /**\n     * Optionally use file content from memory instead of pulling the file content during parser setup.\n     * Used primarily to for performance reasons in mock tests and potentially within the Vite plugin load requests.\n     *\n     * We still want the filePath property to maintain good traceability in error messages.\n     */\n    fileContent?: Promise<string> | string;\n}\n\nexport async function parseMeteorPackage({ fileContent, filePath }: ParseOptions) {\n    const startTime = Date.now();\n    const content = (fileContent || FS.readFile(filePath, 'utf-8'))\n    \n    const result: ParsedPackage = await parseSource(await content);\n    \n    if (!result.name) {\n        throw new ParserError(`Could not extract name from package in: ${filePath}`, {\n            parseOptions: { fileContent, filePath },\n        });\n    }\n    \n    if (!result.packageId) {\n        result.packageId = `meteor/${result.name}`;\n    }\n    \n    const moduleExports = Object.keys(result.modules);\n    const packageExports = Object.keys(result.packageScopeExports);\n    \n    if (!moduleExports.length && !packageExports.length) {\n        console.warn(\n            'Unable to retrieve any metadata from the provided source code!',\n            { result }\n        );\n        throw new ParserError(`No modules or package-scope exports could be extracted from package: ${result.name}`);\n    }\n    \n    return {\n        result,\n        timeSpent: `${Date.now() - startTime}ms`,\n    }\n}\n\n\nfunction parseSource(code: string) {\n    return new Promise<ParsedPackage>((resolve, reject) => {\n        const source = parse(code);\n        const result: ParsedPackage = {\n            name: '',\n            modules: {},\n            packageScopeExports: {},\n            mainModulePath: '',\n            packageId: '',\n            node_modules: [],\n        }\n        \n        traverse(source, {\n            enter(node) {\n                const packageScope = parsePackageScope(node);\n                const { atmosphere, npm } = MeteorInstall.parse(node);\n                result.mainModulePath = readMainModulePath(node) || result.mainModulePath;\n                \n                if (atmosphere) {\n                    Object.assign(result, atmosphere)\n                }\n                \n                if (npm) {\n                    result.node_modules?.push(...npm);\n                }\n                \n                if (packageScope) {\n                    result.name = result.name || packageScope.name;\n                    result.packageScopeExports[packageScope.name] = packageScope.exports;\n                }\n            }\n        });\n        \n        resolve(result);\n    })\n}\n\n/**\n * Try to determine a package's mainModule path by reading the root exports declaration.\n *\n * @example bundle export\n * var exports = require(\"/node_modules/meteor/test:ts-modules/index.ts\");\n */\nfunction readMainModulePath(node: Node) {\n    if (node.type !== 'VariableDeclarator') return;\n    if (!is('Identifier', node.id, { name: 'exports' })) return;\n    if (node.init?.type !== 'CallExpression') return;\n    if (!is('Identifier', node.init.callee, { name: 'require' })) return;\n    if (node.init.arguments[0]?.type !== 'StringLiteral') return;\n    \n    // node_modules/meteor/<author>:<packageName>/<mainModule>\n    return node.init.arguments[0].value;\n}\n\n/**\n * Parse exports at the package namespace. This would be things like global packages (Meteor, Mongo, etc)\n *\n * @example bundle export\n * Package._define(\"mongo\", {\n *   Mongo: Mongo\n * });\n */\nfunction parsePackageScope(node: Node) {\n    function meteorV2(node: Node) {\n        if (node.type !== 'CallExpression') return;\n        if (node.callee.type !== 'MemberExpression') return;\n        const { object, property } = node.callee;\n        if (object.type !== 'Identifier') return;\n        if (object.name !== 'Package') return;\n        if (property.type !== 'Identifier') return;\n        if (property.name !== '_define') return;\n        \n        const args = {\n            packageName: node.arguments[0],\n            moduleExports: node.arguments[1],\n            packageExports: node.arguments[2],\n        }\n        \n        if (args.packageName.type !== 'StringLiteral') {\n            throw new ModuleExportsError('Unexpected type received for package name!', args.packageName);\n        }\n        \n        /**\n         * Deals with the meteor/meteor core packages that don't use the module system.\n         */\n        if (!args.packageExports && args.moduleExports?.type === 'ObjectExpression') {\n            args.packageExports = args.moduleExports;\n        }\n        \n        const packageExport = {\n            name: args.packageName.value,\n            exports: [] as string[],\n        };\n        \n        /**\n         * Module is likely a lazy-loaded package or one that only provides side effects as there are no exports in any\n         * form.\n         */\n        if (!args.packageExports) {\n            return packageExport;\n        }\n        \n        if (args.packageExports.type !== 'ObjectExpression') {\n            throw new ModuleExportsError('Unexpected type received for package-scope exports argument!', args.packageExports);\n        }\n        \n        args.packageExports.properties.forEach((property) => {\n            if (property.type === 'SpreadElement') {\n                throw new ModuleExportsError('Unexpected property type received for package-scope exports!', property)\n            }\n            \n            packageExport.exports.push(propParser.getKey(property));\n        })\n        \n        return packageExport;\n    }\n    \n    \n    function meteorV3(node: Node) {\n        if (!isCallExpression(node)) return;\n        if (!isMemberExpression(node.callee)) return;\n        if (!isIdentifier(node.callee.property, { name: 'queue' })) return;\n        if (!isStringLiteral(node.arguments[0])) return;\n        \n        const packageName = node.arguments[0].value;\n        let packageClosure: FunctionExpression | null = null;\n        const exports: string[] = [];\n        \n        // Meteor V3 (Release Candidate)\n        if (isFunctionExpression(node.arguments[1])) {\n            packageClosure = node.arguments[1];\n        }\n        \n        // Meteor V3 (Beta)\n        if (isFunctionExpression(node.arguments[2])) {\n            packageClosure = node.arguments[2];\n        }\n        \n        if (!packageClosure) {\n            return;\n        }\n        \n        for (const node of packageClosure.body.body) {\n            if (!isReturnStatement(node)) continue;\n            if (!isObjectExpression(node.argument)) continue;\n            for (const property of node.argument.properties) {\n                if (!isObjectProperty(property)) continue;\n                if (!isIdentifier(property.key, { name: 'export' })) continue;\n                if (!isFunctionExpression(property.value)) continue;\n                const exportBody = property.value.body.body;\n                for (const node of exportBody) {\n                    if (!isReturnStatement(node)) continue;\n                    if (!isObjectExpression(node.argument)) continue;\n                    node.argument.properties.forEach((node) => {\n                        if (!isObjectProperty(node)) return;\n                        if (!isIdentifier(node.key)) return;\n                        exports.push(node.key.name);\n                    });\n                    \n                }\n            }\n        }\n        \n        return { name: packageName, exports };\n    }\n    \n    return meteorV2(node) || meteorV3(node);\n}\n\nexport const propParser = {\n    getKey<TProperty extends ObjectMethod | ObjectProperty>(property: TProperty) {\n        if (property.key.type === 'Identifier') {\n            return property.key.name;\n        }\n        if (property.key.type === 'StringLiteral') {\n            return property.key.value;\n        }\n        \n        throw new ModuleExportsError('Unsupported property key type!', property);\n    },\n}\n\n/**\n * Meteor package-level exports.\n * {@link https://docs.meteor.com/api/packagejs.html#PackageAPI-export}\n */\nexport type PackageScopeExports = Record<string, string[]>;\nexport type ModuleList = { [key in string]: ModuleExportData[] };\nexport type ModuleExportData = {\n    /**\n     * \"Name\" of the object to be exported.\n     * @example ts\n     * export const <name> = '...'\n     */\n    name?: string,\n    type: 'export' // Named export (export const fooBar = '...')\n          | 're-export' // Exporting properties from another module. (export { fooBar } from './somewhere'  )\n          | 'global-binding' // Meteor globals. (`Meteor`, `DDP`, etc) These should likely just be excluded from the vite stubs.\n          | 'export-default' // Default module export (export default fooBar);\n    \n    /**\n     * Internal Meteor ID for a linked Meteor module.\n     * This isn't really all that useful apart from testing.\n     */\n    id?: number;\n    \n    /**\n     * The module we're re-exporting from. This only applies to re-exports.\n     * @example ts\n     * export { foo } from '<from>'\n     */\n    from?: string;\n    \n    /**\n     * The value of the \"as\" keyword when exporting a module.\n     * @example ts\n     * export { foo as bar }\n     */\n    as?: string;\n};\n\nexport interface ParsedPackage {\n    /**\n     * Meteor Atmosphere package name.\n     * E.g. ostrio:cookies, accounts-base, ddp\n     */\n    name: string;\n    \n    /**\n     * List of ES modules included in this package.\n     */\n    modules: ModuleList;\n    \n    /**\n     * List of npm packages bundled with this package.\n     * This probably only applies to Meteor's `modules.js` package.\n     */\n    node_modules?: MeteorInstall[];\n    \n    /**\n     * Path to the package's mainModule as defined with `api.mainModule(...)`\n     * {@link https://docs.meteor.com/api/packagejs.html}\n     */\n    mainModulePath?: string;\n    \n    /**\n     * Meteor package-level exports.\n     * {@link https://docs.meteor.com/api/packagejs.html#PackageAPI-export}\n     */\n    packageScopeExports: PackageScopeExports;\n    \n    /**\n     * Whether the parsed package is a Meteor-bundled npm package from modules.js or a normal Meteor package.\n     */\n    type?: 'atmosphere' | 'npm';\n    \n    /**\n     * Base Atmosphere package import This is usually where we find the full package content, even for packages\n     * that have multiple entry points.\n     * E.g. `meteor/ostrio:cookies`, `meteor/meteor`, `meteor/vite:bundler`\n     */\n    packageId: string;\n}","import { is, isObjectExpression, Node, traverse, VariableDeclarator } from '@babel/types';\nimport { PackageModule } from './PackageModule';\nimport { ModuleList, propParser } from './Parser';\nimport { ModuleExportsError } from './ParserError';\nimport { MeteorInstallCallExpression, MeteorInstallMeteorProperty, MeteorPackageProperty } from './ParserTypes';\n\n/**\n * Parser for a build Meteor package's meteorInstall() call.\n * Traverses through all the entries in the passed object to build up a map of each file exposed by the package\n * as well as tracking exports (module.export, module.exportDefault) and re-exports (module.link).\n * {@link https://github.com/JorgenVatle/meteor-vite/blob/8b0a7a5f5f95d78661793e8b4bc7f266c1081ed9/npm-packages/meteor-vite/test/__mocks/meteor-bundle/rdb_svelte-meteor-data.js#L25 example of meteorInstall() }\n */\nexport class MeteorInstall {\n    public readonly modules: ModuleList = {};\n    public readonly type: 'atmosphere' | 'npm';\n    public packageId: string;\n    public name: string;\n    public mainModulePath?: string;\n    public packageJson?: {\n        name: string,\n        version: string,\n        main: string,\n    }\n    \n    constructor({ packageId, name, type }: Pick<MeteorInstall, 'packageId' | 'name' | 'type'>) {\n        this.packageId = packageId;\n        this.name = name;\n        this.type = type;\n    }\n    \n    public static parse(node: Node) {\n        const atmosphere = this.parseAtmosphereInstall(node);\n        const npm = this.parseNpmInstall(node);\n        \n        return { npm, atmosphere };\n    }\n    \n    protected static parseInstall(node: MeteorInstallCallExpression) {\n        const [modules, fileExtensions] = node.arguments;\n        const node_modules = modules.properties[0];\n        if (propParser.getKey(node_modules) !== 'node_modules') {\n            return {\n                type: 'unknown',\n            };\n        }\n        const meteor = node_modules.value.properties[0];\n        if (propParser.getKey(meteor) === 'meteor') {\n            return {\n                type: 'atmosphere',\n                meteor: meteor as MeteorInstallMeteorProperty,\n            };\n        }\n        return {\n            type: 'npm',\n            node_modules,\n        };\n    }\n    \n    protected static parseAtmosphereInstall(node: Node) {\n        if (!this.isRequireDeclaration(node)) return;\n        if (!this.isMeteorInstall(node.init)) return;\n        \n        \n        const { meteor, type } = this.parseInstall(node.init);\n        if (type !== 'atmosphere' || !meteor) {\n            return;\n        }\n        \n        const packageName = meteor.value.properties[0];\n        const packageModules = packageName.value.properties;\n        \n        const meteorPackage = new this({\n            packageId: `${propParser.getKey(meteor)}/${propParser.getKey(packageName)}`,\n            name: propParser.getKey(packageName),\n            type: 'atmosphere',\n        });\n        \n        meteorPackage.traverseModules(packageModules, '');\n        \n        return meteorPackage;\n    }\n    \n    protected static parseNpmInstall(node: Node) {\n        if (!this.isMeteorInstall(node)) return;\n        \n        const { node_modules, type } = this.parseInstall(node);\n        const npmPackages = [];\n        \n        if (type !== 'npm' || !node_modules) return;\n        \n        for (const directory of node_modules.value.properties) {\n            if (!isObjectExpression(directory.value)) return; // Not a directory\n            const npmPackage = new this({\n                type: 'npm',\n                packageId: `${propParser.getKey(directory)}`,\n                name: '',\n            });\n            npmPackage.traverseModules(directory.value.properties as MeteorPackageProperty[], '');\n            npmPackages.push(npmPackage);\n        }\n        \n        return npmPackages;\n    }\n    \n    protected static isRequireDeclaration(node: Node): node is VariableDeclarator {\n        if (node.type !== 'VariableDeclarator') return false;\n        if (node.id.type !== 'Identifier') return false;\n        if (node.id.name !== 'require') return false;\n        \n        return true;\n    }\n    \n    protected static isMeteorInstall(expression?: Node | null): expression is MeteorInstallCallExpression {\n        if (!expression) return false;\n        if (expression.type !== 'CallExpression') return false;\n        if (!is('Identifier', expression.callee, { name: 'meteorInstall' })) return false;\n        \n        return true;\n    }\n    \n    public traverseModules(properties: MeteorPackageProperty[], parentPath: string) {\n        properties.forEach((property) => {\n            const name = propParser.getKey(property);\n            const path = `${parentPath}${name}`;\n            const module = new PackageModule(path);\n            \n            \n            if (property.value.type === 'ObjectExpression') {\n                return this.traverseModules(property.value.properties, `${path}/`);\n            }\n            \n            \n            traverse(property.value.body, {\n                enter(node) {\n                    module.parse(node);\n                },\n            });\n            \n            this.modules[path] = module.exports;\n            \n            if (name !== 'package.json') {\n                return;\n            }\n            if (this.type !== 'npm') {\n                return;\n            }\n            if (!module.jsonContent) {\n                throw new ModuleExportsError(`Unable to parse package.json for ${path}!`, property);\n            }\n            this.packageJson = Object.assign(this.packageJson || {\n                name: '',\n                version: '',\n                main: '',\n            }, module.jsonContent);\n            \n            this.name = this.name || this.packageJson.name;\n            this.packageId = this.packageId || this.packageJson.name;\n            this.mainModulePath = this.mainModulePath || this.packageJson.main;\n        });\n    }\n    \n}","import {\n    isAssignmentExpression,\n    isCallExpression,\n    isIdentifier,\n    isMemberExpression,\n    isObjectExpression,\n    isObjectProperty,\n    isStringLiteral,\n    Node,\n    NumericLiteral,\n    ObjectExpression,\n    StringLiteral,\n} from '@babel/types';\nimport Logger from '../../utilities/Logger';\nimport { ModuleExportData, propParser } from './Parser';\nimport { ModuleExportsError } from './ParserError';\nimport { KnownModuleMethodNames, ModuleMethod, ModuleMethodName } from './ParserTypes';\n\n// List of package.json key warnings already emitted.\n// Prevents us from emitting a warning for a key more than once.\nconst EmittedJsonKeyWarnings: string[] = [];\n\n/**\n * An individual file within a built Meteor package's meteorInstall file tree.\n * It essentially represents a single file and its associated exports within a given Meteor package.\n * E.g. `index.js` or `cookie-store.js`.\n *\n * {@link https://github.com/JorgenVatle/meteor-vite/blob/78a451fa311989d10cbb061bb929d8feb795ea2c/npm-packages/meteor-vite/test/__mocks/meteor-bundle/test_ts-modules.js#L20 `explicit-relative-path.ts`} would count as a module here.\n */\nexport class PackageModule {\n    public readonly exports: ModuleExportData[] = [];\n    public jsonContent?: Record<string, string>\n    \n    constructor(public readonly path: string) {\n    }\n    \n    /**\n     * Helper for checking if an already validated node is of the provided method\n     */\n    protected isMethod<MethodName extends ModuleMethodName>(\n        node: ModuleMethod.MethodMap[ModuleMethodName],\n        method: MethodName,\n    ): node is ModuleMethod.MethodMap[MethodName] {\n        return node.callee.property.name === method;\n    }\n    \n    /**\n     * Check if provided node is a valid `module.[method]` call expression.\n     */\n    protected isModuleMethodCall(node: Node): node is ModuleMethod.MethodMap[ModuleMethodName] {\n        if (node.type !== 'CallExpression') return false;\n        \n        const callee = node.callee;\n        \n        if (callee.type !== 'MemberExpression') return false;\n        if (callee.object.type !== 'Identifier') return false;\n        if (!callee.object.name.match(/^module\\d*$/)) return false;\n        if (callee.property.type !== 'Identifier') return false;\n        const calleeMethod = callee.property.name;\n        \n        if (!KnownModuleMethodNames.includes(calleeMethod as ModuleMethodName)) {\n            Logger.warn(`Meteor module.${calleeMethod}(...) is not recognized by Meteor-Vite! Please open an issue to get this resolved! ðŸ™`);\n            return false;\n        }\n        \n        return true;\n    }\n    \n    protected getModuleExportsAssignment(node: Node) {\n        if (!isAssignmentExpression(node)) return;\n        if (!isMemberExpression(node.left)) return;\n        if (!isIdentifier(node.left.object, { name: 'module' })) return;\n        if (!isIdentifier(node.left.property, { name: 'exports' })) return;\n        \n        return node.right;\n    }\n    \n    protected getCjsExportAssignment(node: Node) {\n        if (!isAssignmentExpression(node)) return;\n        if (!isMemberExpression(node.left)) return;\n        if (!isIdentifier(node.left.object, { name: 'exports' })) return;\n        if (!isIdentifier(node.left.property)) return;\n        \n        return node.left.property;\n    }\n    \n    /**\n     * Parse everything within the current module and store detected exports.\n     * Todo: Possibly migrate parsers to their own class to save on memory usage?\n     */\n    public parse(node: Node) {\n        const moduleExports = this.getModuleExportsAssignment(node);\n        const cjsExport = this.getCjsExportAssignment(node);\n        \n        if (cjsExport) { // export.<name> = (...)\n            this.exports.push({\n                name: cjsExport.name,\n                type: 'export',\n            });\n            return;\n        }\n        \n        \n        if (moduleExports) {\n            if (isCallExpression(moduleExports)) { // module.exports = require('..')\n                if (!isIdentifier(moduleExports.callee, { name: 'require' })) return;\n                if (!isStringLiteral(moduleExports.arguments[0])) return;\n                \n                // Prevent duplicate default exports - React has a conditional export that can cause some issues\n                if (!this.exports.find(({ as, name }) => (as || name) === 'default')) {\n                    this.exports.push({\n                        type: 'export',\n                        name: 'default',\n                    })\n                }\n                this.exports.push({\n                    type: 're-export',\n                    from: moduleExports.arguments[0].value,\n                    name: '*'\n                });\n                return;\n            }\n            if (!isObjectExpression(moduleExports)) {\n                return;\n            }\n            if (this.path.endsWith('map.json')) {\n                return; // Skip parsing source maps\n            }\n            if (this.path.endsWith('package.json')) {\n                this.parseJson(moduleExports);\n            }\n            this.exports.push(...formatExports({ expression: moduleExports }));\n        }\n        \n        if (!this.isModuleMethodCall(node)) return;\n        \n        if (this.isMethod(node, 'link')) {\n            return this.exports.push(...this.parseLink(node));\n        }\n        \n        if (this.isMethod(node, 'export')) {\n            return this.exports.push(...this.parseExport(node));\n        }\n        \n        if (this.isMethod(node, 'exportDefault')) {\n            this.exports.push(...this.parseExportDefault(node));\n            return;\n        }\n    }\n    \n    protected parseJson(moduleExports: ObjectExpression) {\n        this.jsonContent = {};\n        for (const prop of moduleExports.properties) {\n            if (!isObjectProperty(prop)) {\n                throw new ModuleExportsError('JSON module had an unexpected property export', prop);\n            }\n            const key = propParser.getKey(prop);\n            if (!isStringLiteral(prop.value)) {\n                if (EmittedJsonKeyWarnings.includes(key)) {\n                    return;\n                }\n                Logger.warn(new ModuleExportsError(`Meteor bundle had a package.json key (${key}) with an unexpected value.\\nThis might be important to properly parse the module's entrypoint. Do open a new issue if you run into any issues. ðŸ™`, prop));\n                EmittedJsonKeyWarnings.push(key);\n                return;\n            }\n            Object.assign(this.jsonContent, { [key]: prop.value.value });\n        }\n    }\n    \n    /**\n     * Parse a Meteor bundle's `module.link()` call.\n     * {@link ModuleMethod.Link}\n     */\n    protected parseLink(node: ModuleMethod.WithoutArgs<'link'>) {\n        const [importPath, exports, id] = node.arguments;\n        \n        if (importPath.type !== 'StringLiteral') {\n            throw new ModuleExportsError('Expected string as the first argument in module.link()!', importPath);\n        }\n        \n        // Module.link('./some-path') without any arguments.\n        // Translates to `import './some-path' - so no exports to be found here. ðŸ‘\n        if (!exports) return [];\n        \n        if (exports.type !== 'ObjectExpression') {\n            throw new ModuleExportsError(\n                'Expected ObjectExpression as the second argument in module.link()!',\n                importPath,\n            );\n        }\n        if (id?.type !== 'NumericLiteral') {\n            throw new ModuleExportsError('Expected NumericLiteral as the last argument in module.link()!', importPath);\n        }\n        \n        return formatExports({\n            packageName: importPath,\n            expression: exports,\n            id,\n        });\n    }\n    \n    /**\n     * Parse a Meteor bundle's `module.export({ ... })` call.\n     * {@link ModuleMethod.export see type for examples}\n     */\n    protected parseExport(node: ModuleMethod.WithoutArgs<'export'>) {\n        if (node.arguments[0].type !== 'ObjectExpression') {\n            throw new ModuleExportsError('Unexpected export type!', exports);\n        }\n        \n        return formatExports({\n            expression: node.arguments[0],\n        });\n    }\n    \n    /**\n     * Parse a Meteor bundle's `module.exportDefault()` call.\n     * {@link ModuleMethod.exportDefault see examples in type declaration}\n     */\n    protected parseExportDefault(node: ModuleMethod.WithoutArgs<'exportDefault'>) {\n        const args = node.arguments;\n        let name = 'default';\n        if (args[0].type === 'Identifier') {\n            name = args[0].name;\n        } else if (args[0].type === 'ConditionalExpression') {\n            name = 'CONDITIONAL_EXPORT_DEFAULT';\n        } else {\n            new ModuleExportsError('Unexpected default export value!', args[0]);\n        }\n        \n        // todo: test for default exports with `export default { foo: 'bar' }`\n        return [{ type: 'export-default', name } satisfies ModuleExportData];\n    }\n}\n\nfunction formatExports({ expression, packageName, id }: {\n    expression: ObjectExpression,\n    packageName?: StringLiteral,\n    id?: NumericLiteral,\n}) {\n    return expression.properties.map((property) => {\n        if (property.type === 'SpreadElement') throw new ModuleExportsError('Unexpected property type!', property);\n        const result: ModuleExportData = {\n            name: propParser.getKey(property),\n            type: 'export',\n            ...id && { id: id.value },\n        };\n        \n        if (packageName) {\n            result.type = 're-export';\n            result.from = packageName.value;\n        }\n        \n        if (result.type === 're-export' && property.type === 'ObjectMethod') {\n            result.type = 'global-binding';\n        }\n        \n        if (result.type === 're-export' && property.type === 'ObjectProperty') {\n            const content = property.value;\n            if (content.type !== 'StringLiteral') {\n                throw new ModuleExportsError('Received unsupported result type in re-export!', property);\n            }\n            \n            if (content.value !== result.name) {\n                result.as = content.value;\n            }\n        }\n        \n        return result;\n    });\n    \n}","import { Node } from '@babel/types';\nimport { inspect } from 'util';\nimport { MeteorViteError } from '../../error/MeteorViteError';\nimport { ParseOptions } from './Parser';\n\nexport class ParserError extends MeteorViteError {\n    constructor(\n        public originalMessage: string,\n        public readonly metadata?: {\n            parseOptions?: ParseOptions,\n            node?: Node,\n        },\n    ) {\n        super(originalMessage);\n    }\n    \n    public async formatLog() {\n        const { parseOptions, node } = await this.metadata || {};\n        if (parseOptions?.fileContent) {\n            this.addLine([\n                `// File content for: ${this.metadata?.parseOptions?.filePath}`, '',\n            ]);\n            (await parseOptions.fileContent).split(/[\\r\\n]+/).forEach((line) => this.addLine(line));\n        }\n        if (node) {\n            this.addLine([inspect(node)]);\n        }\n    }\n}\n\nexport class ModuleExportsError extends ParserError {\n    constructor(\n        public readonly message: string,\n        public readonly node: Node,\n    ) {\n        super(message, { node });\n    }\n}","import {\n    ArrayExpression,\n    AssignmentExpression,\n    CallExpression, Expression,\n    FunctionExpression,\n    Identifier,\n    MemberExpression, NumericLiteral,\n    ObjectExpression,\n    ObjectProperty,\n    StringLiteral,\n} from '@babel/types';\n\ntype KnownObjectProperty<TValue extends Pick<ObjectProperty, 'key' | 'value'>> = Omit<ObjectProperty, 'key' | 'value'> & TValue;\ntype KnownObjectExpression<TValue extends Pick<ObjectExpression, 'properties'>> = Omit<ObjectExpression, 'properties'> & TValue;\ntype ModuleMethodCall<\n    MethodName extends ModuleMethodName,\n    Arguments extends CallExpression['arguments']\n> = Omit<CallExpression, 'callee' | 'arguments'> & {\n    callee: MemberExpression & {\n        object: Identifier;\n        property: Omit<Identifier, 'name'> & { name: MethodName };\n    }\n    arguments: Arguments\n}\ntype KnownStringLiteral<Value extends string> = Omit<StringLiteral, 'value'> & { value: Value };\ntype KnownIdentifier<Name extends string> = Omit<Identifier, 'name'> & { name: Name };\ntype KnownObjectKey<Value extends string> = KnownStringLiteral<Value> | KnownIdentifier<Value>;\n\nexport namespace ModuleMethod {\n    /**\n     * Meteor's `module.link()` method, exposed internally for built Meteor packages.\n     *\n     * @example package source\n     * export { default } from 'meteor/ostrio:cookies';\n     * export * from 'meteor/tracker;\n     *\n     * @example bundle result\n     * module.link('meteor/ostrio:cookies', {\n     *     default: 'Cookies'\n     * }, 0)\n     * module1.link(\"meteor/tracker\", {\n     *     \"*\": \"*\"\n     * }, 1);\n     */\n    export type Link = ModuleMethodCall<'link', [\n        importPath: StringLiteral, // Hopefully only StringLiteral is all that can be here.\n        exports: ObjectExpression,\n        id: NumericLiteral\n    ] | [importPath: StringLiteral]>;\n\n    /**\n     * Meteor's `module.exportDefault()` method - seems to only be used for modules that are lazy-loaded?\n     * {@link https://github.com/JorgenVatle/meteor-vite/blob/71a1ed5b84439c02f5592bef1d4cf3ae565fa879/npm-packages/meteor-vite/test/__mocks/meteor-bundle/test_ts-modules.js#L42}\n     *\n     * @example Package source\n     * export default namedFunction() {\n     *     return 'foo';\n     * }\n     * @example Bundle result\n     * module1.exportDefault(namedFunction);\n     */\n    export type ExportDefault = ModuleMethodCall<'exportDefault', [\n        CallExpression['arguments'][number], // Can be anything, see ts_modules mock for example\n    ]>\n\n    /**\n     * Meteor's `module.export({ ... })` method. This is essentially ES exports\n     *\n     * @example Package source\n     * export const Foo = 'bar'\n     * export default class FooBar {}\n     *\n     * @example Bundle result\n     * module.export({\n     *     Foo: () => Foo\n     *    FooBar: () => FooBar\n     * })\n     */\n    export type Export = ModuleMethodCall<'export', [\n        ObjectExpression, // todo: Narrow this type further for keys and values (key Identifier/StringLiteral, etc.)\n    ]>\n    \n    /**\n     * Meteor's `module.runSetters()` method.\n     * Todo: Add further documentation\n     *\n     * @example Bundle result\n     * let current_component;\n     * function set_current_component(component) {\n     *   module.runSetters(current_component = component, [\"current_component\"]);\n     * }\n     */\n    export type RunSetters = ModuleMethodCall<'runSetters', [\n        AssignmentExpression, // todo: Verify whether this is the correct type to use here.\n        ArrayExpression, // Todo: Narrow down expected array element types. (type: [string])\n    ]>\n    \n    /**\n     * Meteor's `module.runModuleSetters()` method.\n     * Todo: Document use of this method.\n     * Todo: Add expected argument types.\n     */\n    export type RunModuleSetters = ModuleMethodCall<'runModuleSetters', []>\n\n    export type MethodMap = {\n        export: Export;\n        link: Link;\n        exportDefault: ExportDefault;\n        runSetters: RunSetters;\n        runModuleSetters: RunModuleSetters,\n    }\n\n    /**\n     * Any of the above methods, just that the arguments could be anything at this point.\n     * Assists with the parser's `isMethod()` utility.\n     */\n    export type WithoutArgs<MethodName extends ModuleMethodName> = Omit<MethodMap[MethodName], 'arguments'> & Pick<CallExpression, 'arguments'>\n}\n\nexport type MeteorPackageProperty = KnownObjectProperty<{\n    key: StringLiteral, // File name\n    value: FunctionExpression | MeteorNestedPackageProperty, // Module function\n}>\ntype MeteorNestedPackageProperty = KnownObjectExpression<{\n    properties: MeteorPackageProperty[]\n}>\n\nexport const KnownModuleMethodNames = ['export', 'link', 'exportDefault', 'runSetters', 'runModuleSetters'] as const;\nexport type ModuleMethodName = typeof KnownModuleMethodNames[number];\n\n/**\n * First argument of Meteor's `meteorInstall()` function for its packages.\n * This is an internal method that isn't used by package authors.\n *\n * @example start of the meteorInstall call\n *     {@link https://github.com/JorgenVatle/meteor-vite/blob/85120ec60beccca956c65880e94bce99b338f24e/npm-packages/meteor-vite/test/__mocks/meteor-bundle/rdb_svelte-meteor-data.js#L25 see mock example} var require = meteorInstall({\"node_modules\":{\"meteor\":{\"rdb:svelte-meteor-data\":{\"index.js\":function module(require,exports,module){\n * // ... build package code starts here\n */\nexport type MeteorInstallObject = KnownObjectExpression<{\n    properties: [KnownObjectProperty<{\n        key: KnownObjectKey<'node_modules'>\n        value: KnownObjectExpression<{\n            properties: [MeteorInstallMeteorProperty] | ObjectProperty[]\n        }>\n    }>]\n}>;\n\n/**\n * The contents of a Meteor package as defined in `meteorInstall()`.\n * It's a utility type to allow for a little better ergonomics when we know we're parsing a Meteor package and not an\n * unknown module\n */\nexport type MeteorInstallMeteorProperty = KnownObjectProperty<{\n    key: KnownObjectKey<'meteor'>,\n    value: KnownObjectExpression<{\n        properties: [KnownObjectProperty<{\n            key: KnownObjectKey<string>, // Package name\n            value: KnownObjectExpression<{\n                properties: MeteorPackageProperty[]\n            }>\n        }>]\n    }>\n}>\n\n/**\n * A call expression for the `meteorInstall()` function.\n * We're using this to nicely cast types for meteorInstall() nodes.\n */\nexport type MeteorInstallCallExpression = Omit<CallExpression, 'arguments'> & {\n    arguments: [modules: MeteorInstallObject, fileExtensions: Expression] | [modules: MeteorInstallObject]\n}","import pc from 'picocolors';\nimport Logger from '../../utilities/Logger';\nimport { ErrorMetadata, MeteorViteError } from '../../error/MeteorViteError';\nimport ModuleExport from './components/ModuleExport';\nimport PackageExport from './components/PackageExport';\n\n/**\n * Utility class for soaking up and validating all import/export lines for a given module or package-scope export.\n * The properties here refer to the actual output within a stub.\n * Meaning, an \"import\" more takes the form of a reference to the global Package type.\n *\n * @example import\n * const ${PACKAGE_SCOPE_KEY} = ${TEMPLATE_GLOBAL_KEY}.Package['${this.packageName}']\n */\nexport class SerializationStore {\n    /**\n     * Collection of entries that serialize as a normal export.\n     * @example input\n     * export const foo = 'bar'\n     * export { foo as bar } from './foo/bar'\n     * export * as foobar from './foo/bar'\n     *\n     * @example output\n     * export const foo = ${METEOR_STUB_KEY}.foo\n     * export const bar = ${METEOR_STUB_KEY}.foo\n     * export const foobar = ${METEOR_STUB_KEY}.foobar\n     */\n    protected exports = new Map<string, PackageExport | ModuleExport>;\n    \n    /**\n     * Any export that cannot be serialized using a unique key\n     * @example\n     * export * from './foo/bar'\n     */\n    protected reExportWildcards = new Map<string, ModuleExport>;\n    \n    /**\n     * Any named export that originates from another module.\n     * @example\n     * export * as FooBar from './foo/bar';\n     */\n    protected reExports = new Map<string, ModuleExport>;\n    \n    /**\n     * Package imports. These do not serialize to ES imports, but rather references to the global Package type where\n     * we will simulate a re-export from the given package.\n     *\n     * @example import\n     * const ${PACKAGE_SCOPE_KEY} = ${TEMPLATE_GLOBAL_KEY}.Package['my:package']\n     *\n     * @example export\n     * export const foo = ${PACKAGE_SCOPE_KEY}.foo\n     */\n    protected imports = new Map<string, PackageExport>();\n    \n    /**\n     * Re-exports mapped by the path they are exporting from.\n     *\n     * @example source input\n     * export { foo, bar } from 'meteor/foobar'\n     * export * as Hello from 'meteor/hello'\n     * @example map output\n     * ['meteor/foobar', [ModuleExport, ModuleExport]]\n     * ['meteor/hello', [ModuleExport]]\n     */\n    protected reExportsPathMap = new Map<string, ModuleExport[]>;\n    \n    constructor() {\n    }\n    \n    protected addPackageExport(entry: PackageExport) {\n        const existing = this.exports.get(entry.key);\n        \n        if (existing) {\n            return Logger.debug(\n                `Discarded submodule entry for package export as there already is an export for it`,\n                { existing, entry },\n            );\n        }\n        \n        this.imports.set(entry.packageName, entry);\n        this.exports.set(entry.key, entry);\n    }\n    \n    public addEntry(entry: PackageExport | ModuleExport) {\n        if (entry instanceof PackageExport) {\n            return this.addPackageExport(entry);\n        }\n        \n        if (entry.placement === 'none') {\n            return;\n        }\n        \n        if (entry.stubType === 'export-all') {\n            this.reExportWildcards.set(entry.from!, entry);\n            return;\n        }\n        \n        this.validateNewKey(entry);\n        \n        if (entry.stubType === 're-export') {\n            if (!entry.from) throw new ReExportWithoutPath('Detected a re-export entry without a \"from\" path!', { export: entry });\n            const pathMap = this.reExportsPathMap.get(entry.from) || this.reExportsPathMap.set(entry.from, []).get(entry.from)!;\n            this.reExports.set(entry.key, entry);\n            pathMap.push(entry);\n            return;\n        }\n        \n        this.exports.set(entry.key, entry);\n    }\n    \n    public validateNewKey(entry: ModuleExport): asserts entry is ModuleExport & { key: string } {\n        if (!entry.key) {\n            throw new MeteorViteError('Unable to determine type for module export!', { cause: entry });\n        }\n        \n        const existing = this.exports.get(entry.key);\n        const existingReExport = this.reExports.get(entry.key)\n        \n        if (existing instanceof ModuleExport) {\n            throw new ConflictingExportKeys(\n                `Duplicate module export detected in ${pc.yellow(entry.parentModule.meteorPackage.packageId)}!`,\n                { conflict: { thisExport: entry, conflictedWith: existing } },\n            );\n        }\n        if (existingReExport) {\n            throw new ConflictingExportKeys(\n                `Export key is conflicting with a module re-export in ${pc.yellow(entry.parentModule.meteorPackage.packageId)}!`,\n                { conflict: { thisExport: entry, conflictedWith: existingReExport } },\n            );\n        }\n    }\n    \n    public serialize() {\n        const exports = new Set<string>;\n        const reExports = new Set<string>;\n        const imports = new Set<string>;\n        \n        this.reExportWildcards.forEach((entry) => reExports.add(entry.serialize()));\n        this.reExportsPathMap.forEach((entry, path) => {\n            const exportKeys = entry.map(entry => entry.serialize({ chainedReExport: true })).join(', ')\n            return reExports.add(`export { ${exportKeys} } from '${path}';`);\n        });\n        \n        this.imports.forEach((entry) => imports.add(entry.serializeImport()));\n        this.exports.forEach((entry) => exports.add(entry.serialize()));\n        \n        return {\n            imports: [...imports],\n            reExports: [...reExports],\n            exports: [...exports],\n            exportKeys: [\n                ...this.reExports.keys(),\n                ...this.exports.keys()\n            ],\n        };\n    }\n}\n\nexport class ReExportWithoutPath extends MeteorViteError {\n    constructor(message: string, meta: ErrorMetadata & { export: ModuleExport }) {\n        super(message, meta);\n        this.addSection('Offending export', meta.export);\n    }\n}\n\nexport class ConflictingExportKeys extends MeteorViteError {\n    constructor(\n        message: string,\n        public readonly meta: ErrorMetadata & {\n            conflict: {\n                thisExport: ModuleExport | PackageExport\n                conflictedWith: ModuleExport | PackageExport;\n            }\n        },\n    ) {\n        super(message, meta);\n    }\n    \n    protected async formatLog() {\n        const { thisExport, conflictedWith } = this.meta.conflict;\n        this.addSection('Conflict', {\n            exportKey: thisExport.key,\n        });\n        this.addSection('This export', thisExport);\n        this.addSection('Conflicted with', conflictedWith);\n    }\n}","import { ErrorMetadata, MeteorViteError } from '../../../error/MeteorViteError';\nimport { PackageSubmodule } from './PackageSubmodule';\nimport { ModuleExportData } from '../../parser/Parser';\nimport { METEOR_STUB_KEY } from '../StubTemplate';\n\nexport default class ModuleExport implements ModuleExportData {\n    public readonly parentModule: PackageSubmodule;\n    public readonly from;\n    public readonly as;\n    public readonly type;\n    public readonly name;\n    public readonly id;\n    public readonly stubType;\n    \n    constructor(details: { data: ModuleExportData, parentModule: PackageSubmodule }) {\n        this.parentModule = details.parentModule;\n        const { from, as, type, name, id } = details.data;\n        this.from = from;\n        this.as = as;\n        this.name = name;\n        this.id = id;\n        this.type = type;\n        this.stubType = this.determineStubType(type);\n    }\n    \n    /**\n     * Whether this entry needs to be placed at the top of a file, or at the bottom of a file.\n     * Just so we don't end up placing `export { foo } from 'meteor/foo:bar'` statements at a place where it can\n     * break syntax.\n     * // If the placement is 'none', the entry should just be omitted\n     *\n     * In short, we want re-exports from other modules to be at the top of the file, while normal exports are left\n     * at the bottom of the file.\n     */\n    public get placement(): 'top' | 'bottom' | 'none' {\n        if (this.stubType === 're-export') {\n            return 'top'\n        }\n        if (this.stubType === 'global-binding') {\n            return 'none'\n        }\n        return 'bottom';\n    }\n    \n    /**\n     * Determine the export type to be used within a stub template for the current export.\n     */\n    protected determineStubType(type: ModuleExportData['type']): ModuleExportData['type'] | 'export-all' {\n        // Standard exports\n        if (type === 'export') {\n            if (this.name === 'default') {\n                return 'export-default' as const\n            }\n            return 'export' as const\n        }\n        \n        if (type === 'export-default') {\n            return 'export-default' as const;\n        }\n        \n        if (type === 're-export') {\n            \n            // Wildcard re-exports\n            if (this.name?.trim() === '*') {\n                if (!this.as) {\n                    return 'export-all' as const;\n                }\n                if (this.isReExportedByParent) {\n                    if (this.as === 'default') {\n                        return 'export-default';\n                    }\n                    return 'export' as const;\n                }\n                return 're-export' as const;\n            }\n            \n            // Named re-exports\n            if (this.isReExportedByParent) {\n                if (this.as === 'default') {\n                    return 'export-default' as const;\n                }\n                return 'export' as const;\n            }\n            \n            return 're-export' as const;\n        }\n        \n        return type;\n    }\n    \n    /**\n     * The export key for the current entry.\n     * Undefined if not applicable.\n     *\n     * @example\n     * export const FooBar = '' // key is FooBar\n     * export * from './somewhere' // key is undefined\n     * export * as MyModule from './somewhere-else' // key is MyModule\n     */\n    public get key(): string | undefined  {\n        if (this.name?.trim() === '*') {\n            return;\n        }\n        if (this.type === 'export-default') {\n            return 'default';\n        }\n        if (this.type === 'export') {\n            return this.name;\n        }\n        if (this.type === 're-export') {\n            return this.as || this.name;\n        }\n    }\n    \n    /**\n     * Full export path for the current export, if it is a re-export\n     */\n    public get exportPath() {\n        if (this.type !== 're-export') {\n            return;\n        }\n        if (this.from?.startsWith('.')) {\n            return `${this.parentModule.meteorPackage.packageId}/${this.from?.replace(/^[./]+/, '')}`;\n        }\n        return this.from;\n    }\n    \n    public get isReExportedByParent() {\n        if (this.type !== 're-export') {\n            return false;\n        }\n        if (this.from?.startsWith('./')) {\n            return true;\n        }\n        return false;\n    }\n    \n    /**\n     * The current export entry, converted into JavaScript for use as a Meteor stub.\n     * Essentially, converting from raw data back into JavaScript.\n     */\n    public serialize({ chainedReExport = false } = {}) {\n        switch (this.stubType) {\n            case 're-export':\n                const key = `${this.name}${this.key && ` as ${this.key}` || ''}`\n                if (chainedReExport) {\n                    return key;\n                }\n                return `export { ${key} } from '${this.exportPath}';`\n            case 'export':\n                return `export const ${this.key} = ${METEOR_STUB_KEY}.${this.key};`\n            case 'export-default':\n                return `export default ${METEOR_STUB_KEY}.default ?? ${METEOR_STUB_KEY};`\n            case 'export-all':\n                return `export * from '${this.exportPath}';`\n            case 'global-binding':\n                return `/* global binding: ${this.name} */`;\n        }\n        \n        throw new ExportEntrySerializationError(`Unexpected export classification for export: ${this.name} in ${this.parentModule.modulePath}`, { exportEntry: this })\n    }\n}\n\nclass ExportEntrySerializationError extends MeteorViteError {\n    constructor(message: string, meta: ErrorMetadata & { exportEntry: ModuleExport }) {\n        super(message, meta);\n        this.addSection('Cause', meta.exportEntry);\n    }\n}","import pc from 'picocolors';\nimport PackageJSON from '../../../../package.json';\nimport Logger from '../../../utilities/Logger';\nimport { PACKAGE_SCOPE_KEY, TEMPLATE_GLOBAL_KEY } from '../StubTemplate';\nimport MeteorPackage from './MeteorPackage';\n\nexport default class PackageExport {\n    \n    public readonly meteorPackage: MeteorPackage;\n    public readonly packageName: string;\n    public readonly key: string;\n    \n    constructor({ meteorPackage, key, packageName }: { meteorPackage: MeteorPackage, key: string, packageName: string }) {\n        this.meteorPackage = meteorPackage;\n        this.packageName = packageName;\n        this.key = key;\n        \n        if (meteorPackage.name !== packageName) {\n            Logger.warn(`Detected multiple package definitions within ${pc.yellow(this.meteorPackage.name)}! Please report this to ${PackageJSON.bugs.url}`)\n            Logger.warn(`Package ${pc.red(packageName)} was defined within ${pc.yellow(meteorPackage.name)} ðŸ¤”`);\n        }\n    }\n    \n    public serialize() {\n        return `export const ${this.key} = ${PACKAGE_SCOPE_KEY}.${this.key};`\n    }\n    \n    public serializeImport() {\n        return `const ${PACKAGE_SCOPE_KEY} = ${TEMPLATE_GLOBAL_KEY}.Package['${this.packageName}']`\n    }\n}","import { ModuleExportData } from '../../parser/Parser';\nimport type MeteorPackage from './MeteorPackage';\nimport ModuleExport from './ModuleExport';\n\nexport class PackageSubmodule {\n    \n    /**\n     * Relative path from the package name to the module containing these exports.\n     * @example\n     * 'cookie-store.js'\n     */\n    public readonly modulePath: string;\n    \n    /**\n     * ESM exports from the Meteor package module.\n     * @example\n     * export const foo = '...'\n     */\n    public readonly exports: ModuleExport[];\n    \n    /**\n     * The Meteor package this submodule belongs to.\n     * @type {MeteorPackage}\n     */\n    public readonly meteorPackage: MeteorPackage;\n    \n    /**\n     * Full import path for the package's requested module.\n     * @example\n     * 'meteor/ostrio:cookies/cookie-store.js'\n     */\n    public get fullImportPath() {\n        return `${this.meteorPackage.packageId}${this.modulePath ? `/${this.modulePath}` : ''}`\n    };\n    \n    constructor({ meteorPackage, modulePath, exports }: PackageSubmoduleOptions) {\n        this.modulePath = modulePath;\n        this.meteorPackage = meteorPackage;\n        this.exports = exports.map((data) => new ModuleExport({ data, parentModule: this }));\n    }\n    \n}\n\ninterface PackageSubmoduleOptions {\n    /**\n     * ESM exports from the Meteor package module.\n     * @example\n     * export const foo = '...'\n     */\n    exports: ModuleExportData[];\n    \n    /**\n     * Path relative to the current package to the module containing the these exports.\n     * @example\n     * 'meteor/ddp' // -> ''\n     * 'meteor/ostrio:cookies' // -> ''\n     * 'meteor/ostrio:cookies/cookie-store.js' // -> 'cookie-store.js'\n     */\n    modulePath: string;\n    \n    /**\n     * Instance of the Meteor package this submodule belongs to.\n     */\n    meteorPackage: MeteorPackage;\n}","import ViteLoadRequest, { RefreshNeeded } from '../ViteLoadRequest';\nimport { FatalMeteorViteError, MeteorViteError } from './MeteorViteError';\n\nexport function createErrorHandler(fallbackDescription: string, request?: ViteLoadRequest) {\n    return async (error: unknown): Promise<never> => {\n        const viteError = await formatError(fallbackDescription, error);\n        \n        if (request) {\n            viteError.setContext(request);\n        }\n        \n        if (viteError instanceof RefreshNeeded) {\n            return handleRefreshNeeded(viteError);\n        }\n        \n        await viteError.beautify()\n        if (error instanceof FatalMeteorViteError) {\n            console.error(error);\n            process.exit(1);\n        }\n        \n        throw error;\n    }\n}\n\nfunction formatError(fallbackDescription: string, error: unknown | Error) {\n    if (!(error instanceof Error)) {\n        return new MeteorViteError('Received an unexpected error format!', { cause: error });\n    }\n    \n    if (!(error instanceof MeteorViteError)) {\n        return new MeteorViteError(fallbackDescription, {\n            cause: error,\n        })\n    }\n    \n    return error;\n}\n\nlet lastEmittedWarning = Date.now();\n\n/**\n * Only really gets to this point if the Vite worker times out waiting for Meteor to emit a \"client refresh\" IPC\n * message.\n * TODO: Forcefully restart Meteor server once the warning is emitted.\n * @param {RefreshNeeded} error\n * @returns {never}\n */\nfunction handleRefreshNeeded(error: RefreshNeeded): never {\n    if (1000 < Date.now() - lastEmittedWarning) {\n        console.warn(error.message);\n        process.emitWarning('Refresh needed!', error.constructor.name);\n        lastEmittedWarning = Date.now();\n    }\n    throw error;\n}","export default function CreateIPCInterface<\n    Methods extends {\n        [key in string]: (reply: IPCReply<{ readonly kind: string, data: unknown }>, ...params: [params: any]) => void;\n    },\n>(methods: Methods) {\n    return methods;\n}\n\nexport type IPCInterface<Methods, Replies> = { [key in keyof Methods]: (reply: (data: Replies) => void) => void }\n\nexport type IPCReply<Reply extends {\n    readonly kind: string;\n    data: unknown;\n}> = (reply: Reply) => void;\n\nexport function validateIpcChannel(send: NodeJS.Process['send']): asserts send is Required<Pick<NodeJS.Process, 'send'>>['send'] {\n    if (typeof process.send !== 'function') {\n        throw new Error('Worker was not launched with an IPC channel!');\n    }\n}","import { spawn } from 'child_process';\nimport Path from 'path';\nimport { RollupOutput } from 'rollup';\nimport { build, InlineConfig, resolveConfig } from 'vite';\nimport MeteorVitePackage from '../../../../package.json';\nimport {\n    type ResolvedMeteorViteConfig,\n    type ProjectJson,\n    type MeteorStubsSettings,\n} from '../../../VitePluginSettings';\nimport { meteorWorker } from '../../../plugin/Meteor';\nimport CreateIPCInterface, { IPCReply } from '../interface';\n\ntype BuildOutput = Awaited<ReturnType<typeof build>>;\n\nexport default CreateIPCInterface({\n    async 'vite.build'(\n        reply: Replies,\n        buildConfig: BuildOptions\n    ) {\n        try {\n            const { viteConfig, inlineBuildConfig, outDir } = await prepareConfig(buildConfig);\n            const results = await build(inlineBuildConfig);\n            const result = Array.isArray(results) ? results[0] : results;\n            validateOutput(result);\n\n            // Result payload\n            reply({\n                kind: 'buildResult',\n                data: {\n                    payload: {\n                        outDir,\n                        success: true,\n                        meteorViteConfig: viteConfig.meteor,\n                        output: result.output.map(o => ({\n                            name: o.name,\n                            type: o.type,\n                            fileName: o.fileName,\n                        })),\n                    },\n                }\n            })\n        } catch (error) {\n            reply({\n                kind: 'buildResult',\n                data: {\n                    payload: {\n                        success: false\n                    },\n                }\n            })\n            throw error;\n        }\n    },\n    \n    /**\n     * Internal command for spinning up a watcher to rebuild meteor-vite on changes.\n     * Used to ease with the development of this package while running one of the example apps.\n     * Controlled through environment variables applied by the example-app.sh utility script.\n     */\n    async 'tsup.watch.meteor-vite'(reply) {\n        const npmPackagePath = Path.join(process.cwd(), '/node_modules/meteor-vite/') // to the meteor-vite npm package\n        const tsupPath = Path.join(npmPackagePath, '/node_modules/.bin/tsup-node'); // tsup to 2 node_modules dirs down.\n        \n        const child = spawn(tsupPath, ['--watch'], {\n            stdio: 'inherit',\n            cwd: npmPackagePath,\n            detached: false,\n            env: {\n                FORCE_COLOR: '3',\n            },\n        });\n        \n        child.on('error', (error) => {\n            throw new Error(`meteor-vite package build worker error: ${error.message}`, { cause: error })\n        });\n        \n        child.on('exit', (code) => {\n            if (!code) {\n                return;\n            }\n            process.exit(1);\n            throw new Error('TSUp watcher exited unexpectedly!');\n        });\n    }\n})\n\nasync function prepareConfig(buildConfig: BuildOptions): Promise<ParsedConfig> {\n    const { meteor, packageJson } = buildConfig;\n    const configFile = buildConfig.packageJson?.meteor?.vite?.configFile\n        // Fallback for deprecated config file format\n        ?? buildConfig.packageJson?.meteor?.viteConfig;\n\n    Object.entries(buildConfig).forEach(([key, value]) => {\n        if (!value) {\n            throw new Error(`Vite: Worker missing required build argument \"${key}\"!`)\n        }\n    })\n\n    const viteConfig: ResolvedMeteorViteConfig = await resolveConfig({\n        configFile,\n        plugins: [\n            meteorWorker({}) // Fills in defaults for missing fields.\n        ]\n    }, 'build');\n\n    if (!viteConfig.meteor?.clientEntry) {\n        throw new Error(`You need to specify an entrypoint in your Vite config! See: ${MeteorVitePackage.homepage}`);\n    }\n\n    const outDir = Path.join(viteConfig.meteor.tempDir, 'bundle');\n    return {\n        viteConfig,\n        outDir,\n        inlineBuildConfig: {\n            configFile,\n            build: {\n                lib: {\n                    entry: viteConfig.meteor.clientEntry,\n                    formats: ['es'],\n                },\n                rollupOptions: {\n                    output: {\n                        entryFileNames: 'meteor-entry.js',\n                        chunkFileNames: viteConfig.meteor.chunkFileNames ?? '[name]-[hash:12].js',\n                    },\n                },\n                outDir,\n                minify: false,\n            },\n            plugins: [\n                meteorWorker({\n                    meteorStubs: {\n                        meteor,\n                        packageJson,\n                    },\n                }),\n            ],\n        }\n    }\n}\n\nfunction validateOutput(rollupResult?: BuildOutput | RollupOutput): asserts rollupResult is RollupOutput {\n    if (!rollupResult) {\n        throw new Error('Received no result from Rollup!');\n    }\n\n    if ('output' in rollupResult) {\n        return;\n    }\n\n    const message = 'Unexpected rollup result!';\n    console.error(message, rollupResult);\n    throw new Error(message);\n}\n\nexport interface BuildOptions {\n    meteor: MeteorStubsSettings['meteor'];\n    packageJson: ProjectJson;\n}\n\ntype Replies = IPCReply<{\n    kind: 'buildResult',\n    data: {\n        payload: {\n                     success: true;\n                     outDir: string;\n                     meteorViteConfig: any,\n                     output?: {name?: string, type: string, fileName: string}[]\n                 } | {\n                     success: false;\n                 };\n    }\n}>\n\ntype ParsedConfig = {\n    viteConfig: ResolvedMeteorViteConfig;\n    inlineBuildConfig: InlineConfig;\n    outDir: string;\n}\n\n\n","import Path from 'path';\nimport pc from 'picocolors';\nimport { Plugin, PluginOption, ResolvedConfig, UserConfig } from 'vite';\nimport PackageJSON from '../../package.json';\nimport { FatalMeteorViteError } from '../error/MeteorViteError';\nimport type { PartialPluginOptions, PluginOptions, PluginSettings } from '../VitePluginSettings';\nimport { MeteorStubs } from './MeteorStubs';\nimport { mergeWithTypes, parseConfig } from './ParseConfig';\n\n/**\n * Configure the Meteor-Vite compiler.\n * Will be added automatically by Meteor if omitted.\n *\n * Just make sure you set your {@link https://github.com/JorgenVatle/meteor-vite#installation clientEntry} either using\n * this plugin, or in your vite config.\n *\n * @example plugin (recommended)\n * export default defineConfig({\n *     plugins: [\n *         meteor({ clientEntry: './imports/entrypoint/vite.js' })\n *     ]\n * })\n *\n * @example vite config\n * export default defineConfig({\n *     meteor: {\n *         clientEntry: './imports/entrypoint/vite.js',\n *     }\n * })\n */\nexport default function meteor(config: PluginOptions) {\n    return meteorWorker(config);\n}\n\n/**\n * Internal worker plugin. Merges the user's config with necessary overrides for the Meteor compiler and loads the\n * MeteorStubs plugin.\n */\nexport function meteorWorker(config: PartialPluginOptions): PluginOption {\n    const METEOR_LOCAL_DIR = process.env.METEOR_LOCAL_DIR || Path.join('.meteor', 'local');\n    let enforce: 'pre' | undefined;\n    let resolveId: Plugin['resolveId'];\n    \n    if (config.externalizeNpmPackages) {\n        enforce = 'pre';\n        resolveId = function resolveId(id) {\n            const [module, ...path] = id.split('/');\n            const match = config.externalizeNpmPackages?.find((name) => {\n                if (!name) return false;\n                if (module !== name) return false;\n                return true;\n            });\n            if (!match) {\n                return;\n            }\n            return `\\0meteor:${id}`;\n        }\n    }\n    \n    return [\n        {\n            name: 'meteor-vite:config',\n            enforce,\n            resolveId,\n            config: (userConfig) =>  {\n                const pluginSettings = mergeMeteorSettings(userConfig, {\n                    meteorStubs: {\n                        packageJsonPath: 'package.json',\n                        meteor: {\n                            packagePath: Path.join(METEOR_LOCAL_DIR, 'build', 'programs', 'web.browser', 'packages'),\n                            isopackPath: Path.join(METEOR_LOCAL_DIR, 'isopacks'),\n                        }\n                    },\n                    tempDir: Path.join(METEOR_LOCAL_DIR, 'vite'),\n                    stubValidation: {\n                        warnOnly: process.env.NODE_ENV === 'production',\n                        disabled: false,\n                    }\n                }, config);\n                \n                const mergedUserConfig = mergeViteSettings(userConfig, {\n                    optimizeDeps: {\n                        entries: [pluginSettings.clientEntry]\n                    }\n                });\n                \n                userConfig.optimizeDeps = mergedUserConfig.optimizeDeps;\n            },\n            configResolved(resolvedConfig) {\n                const config = parseConfig(resolvedConfig);\n                if (!config.meteor) {\n                    throw new FatalMeteorViteError(\n                        `Could not retrieve Meteor-Vite settings! Did you forget to add ${pc.yellow('meteor-vite')} to your Vite config?`,\n                        {\n                            subtitle: `See the following link for a setup guide ${PackageJSON.homepage}`\n                        }\n                    )\n                }\n                \n                if (!config.meteor.clientEntry) {\n                    throw new FatalMeteorViteError(`You need to specify an entrypoint for Vite!`, {\n                        subtitle: `More info available here ${PackageJSON.homepage}`\n                    })\n                }\n            }\n        },\n        MeteorStubs(),\n    ]\n}\n\nfunction mergeMeteorSettings(\n    userConfig: ResolvedConfig | UserConfig,\n    defaults: PartialPluginOptions,\n    overrides: PartialPluginOptions\n) {\n    const viteConfig = parseConfig(userConfig);\n    const existingSettings = viteConfig.meteor || {};\n    const withDefaults = mergeWithTypes(defaults, existingSettings);\n    return viteConfig.meteor = mergeWithTypes(withDefaults, overrides) as PluginSettings;\n}\n\nfunction mergeViteSettings(\n    userConfig: ResolvedConfig | UserConfig,\n    defaults: UserConfig,\n) {\n    const viteConfig = parseConfig(userConfig);\n    return mergeWithTypes(defaults, viteConfig);\n}\n","import FS from 'fs/promises';\nimport Path from 'path';\nimport pc from 'picocolors';\nimport type { PluginContext } from 'rollup';\nimport type { Plugin, ViteDevServer } from 'vite';\nimport PackageJSON from '../../package.json';\nimport { createErrorHandler } from '../error/ErrorHandler';\nimport { MeteorViteError } from '../error/MeteorViteError';\nimport MeteorPackage from '../meteor/package/components/MeteorPackage';\nimport { stubTemplate } from '../meteor/package/StubTemplate';\nimport ViteLoadRequest from '../ViteLoadRequest';\nimport { type PluginSettings, ResolvedMeteorViteConfig } from '../VitePluginSettings';\n\nexport const MeteorStubs = setupPlugin(async () => {\n    return {\n        name: 'meteor-vite: stubs',\n        resolveId: (id) => ViteLoadRequest.resolveId(id),\n        shouldProcess: (viteId) => ViteLoadRequest.isStubRequest(viteId),\n        async validateConfig({ meteorStubs }: ResolvedPluginConfig) {\n            if (!meteorStubs.packageJson) {\n                const jsonPath = meteorStubs.packageJsonPath || 'package.json';\n                meteorStubs.packageJson = JSON.parse(await FS.readFile(jsonPath, 'utf-8'));\n            }\n            if (!meteorStubs?.packageJson?.meteor?.mainModule?.client) {\n                throw new MeteorViteError(`You need to specify a Meteor entrypoint in your package.json!`, {\n                    subtitle: `See the following link for more info: ${PackageJSON.homepage}`\n                })\n            }\n        },\n        async setupContext(viteId, server, pluginSettings: ResolvedPluginConfig) {\n            return ViteLoadRequest.prepareContext({ id: viteId, pluginSettings, server });\n        },\n        \n        async load(request) {\n            const timeStarted = Date.now();\n            \n            if (request.isLazyLoaded) {\n                await request.forceImport();\n            }\n            \n            const meteorPackage = await MeteorPackage.parse({\n                filePath: request.context.file.sourcePath,\n                fileContent: request.context.file.content,\n            }, {\n                ignoreDuplicateExportsInPackages: request.context.pluginSettings.stubValidation.ignoreDuplicateExportsInPackages\n            });\n            \n            const template = stubTemplate({\n                requestId: request.context.id,\n                importPath: request.requestedModulePath,\n                stubValidation: request.context.pluginSettings.stubValidation,\n                meteorPackage,\n            })\n            \n            request.log.debug(`Meteor stub created`, {\n                'Parse time': meteorPackage.meta.timeSpent,\n                'Request duration': `${Date.now() - timeStarted}ms`,\n            });\n            \n            if (request.context.pluginSettings.meteorStubs.debug) {\n                await storeDebugSnippet({ request, stubTemplate: template, meteorPackage })\n            }\n            \n            return template;\n        },\n    }\n})\n\nasync function storeDebugSnippet({ request, stubTemplate, meteorPackage }: {\n    request: ViteLoadRequest,\n    stubTemplate: string,\n    meteorPackage: MeteorPackage,\n}) {\n    const baseDir = Path.join(request.context.pluginSettings.tempDir, 'stubs', request.context.file.packageId.replace(':', '_'));\n    const templatePath = Path.join(baseDir, request.context.file.importPath || '', 'template.js');\n    const packagePath = Path.join(baseDir, 'package.js');\n    const parserPath = Path.join(baseDir, 'parsed.json');\n    \n    await FS.mkdir(Path.dirname(templatePath), { recursive: true });\n    \n    await Promise.all([\n        FS.writeFile(templatePath, stubTemplate),\n        FS.writeFile(packagePath, await request.context.file.content),\n        FS.writeFile(parserPath, meteorPackage.toJson())\n    ]);\n    \n    request.log.info('Stored debug snippets', {\n        File: pc.cyan(baseDir),\n    })\n}\n\n/**\n * Vite plugin options wrapper.\n * Just a utility to set up catch blocks for nicer error handling as well as pre-populating the load() handler with\n * the request context from {@link ViteLoadRequest}.\n */\nfunction setupPlugin<Context extends ViteLoadRequest>(setup: () => Promise<{\n    name: string;\n    load(this: PluginContext, request: Context): Promise<string>;\n    validateConfig(settings: PluginSettings): Promise<void>,\n    setupContext(viteId: string, server: ViteDevServer, settings: PluginSettings): Promise<Context>;\n    shouldProcess(viteId: string): boolean;\n    resolveId(viteId: string): string | undefined;\n}>): () => Promise<Plugin> {\n    const handleError = createErrorHandler('Could not set up Vite plugin!');\n    \n    const createPlugin = async (): Promise<Plugin> => {\n        const plugin = await setup();\n        let settings: PluginSettings;\n        let server: ViteDevServer;\n        return {\n            name: plugin.name,\n            resolveId: plugin.resolveId,\n            async configResolved(resolvedConfig) {\n                const pluginSettings = (resolvedConfig as ResolvedMeteorViteConfig).meteor;\n                if (!pluginSettings) {\n                    throw new MeteorViteError('Unable to get configuration for Meteor-Vite!');\n                }\n                try {\n                    settings = pluginSettings;\n                    await plugin.validateConfig(pluginSettings);\n                } catch (error) {\n                    await handleError(error);\n                }\n            },\n            configureServer(viteDevServer) {\n                server = viteDevServer;\n            },\n            async load(this: PluginContext, viteId: string) {\n                const shouldProcess = plugin.shouldProcess(viteId);\n                \n                if (!shouldProcess) {\n                    return;\n                }\n                \n                const request = await plugin.setupContext(viteId, server, settings);\n                \n                return plugin.load.apply(this, [request]).catch(\n                    createErrorHandler('Could not parse Meteor package', request)\n                )\n            },\n        }\n    }\n    \n    return () => createPlugin().catch(handleError)\n}\n\n\ntype ResolvedPluginConfig = Required<PluginSettings>;\n\n","import { mergeConfig, ResolvedConfig, UserConfig } from 'vite';\nimport type { PluginSettings } from '../VitePluginSettings';\n\nexport function mergeWithTypes<\n    TDefaults extends Record<string, any>,\n    TOverrides extends Record<string, any>,\n>(defaults: TDefaults, overrides: TOverrides) {\n    return mergeConfig(defaults as any, overrides as any) as TDefaults & TOverrides;\n}\n\nexport function parseConfig<TConfig extends ResolvedConfig | UserConfig>(config: TConfig): TConfig & {\n    meteor?: PluginSettings\n} {\n    return config;\n}\n\n","import FS from 'fs/promises';\nimport Path from 'path';\nimport { createServer, resolveConfig, type ResolvedServerUrls, ViteDevServer } from 'vite';\nimport { meteorWorker } from '../../../plugin/Meteor';\nimport Logger from '../../../utilities/Logger';\nimport { RefreshNeeded } from '../../../ViteLoadRequest';\nimport { type ProjectJson, ResolvedMeteorViteConfig } from '../../../VitePluginSettings';\nimport CreateIPCInterface, { IPCReply } from '../interface';\nimport MeteorEvents, { MeteorIPCMessage } from '../MeteorEvents';\n\nlet server: ViteDevServer & { config: ResolvedMeteorViteConfig };\nlet viteConfig: ResolvedMeteorViteConfig;\nlet listening = false;\n\nexport type Replies = IPCReply<{\n    kind: 'viteConfig',\n    data: ViteRuntimeConfig;\n} | {\n    kind: 'refreshNeeded',\n    data: {},\n} | {\n    kind: 'workerConfig';\n    data: WorkerRuntimeConfig & { listening: boolean };\n}>\n\nexport type ViteRuntimeConfig = {\n    host?: string | boolean;\n    port?: number;\n    resolvedUrls?: ResolvedServerUrls,\n    entryFile?: string\n    backgroundWorker?: WorkerRuntimeConfig;\n}\nexport interface DevServerOptions {\n    packageJson: ProjectJson,\n    meteorParentPid: number;\n}\n\nexport default CreateIPCInterface({\n    async 'vite.server.getConfig'(replyInterface: Replies) {\n        await sendViteConfig(replyInterface);\n    },\n    \n    async 'meteor.events.emit'(reply, data: MeteorIPCMessage) {\n        MeteorEvents.ingest(data);\n    },\n    \n    // todo: Add reply for triggering a server restart\n    async 'vite.server.start'(replyInterface: Replies, { packageJson, meteorParentPid }: DevServerOptions) {\n        const backgroundWorker = await BackgroundWorker.init(meteorParentPid);\n        \n        if (backgroundWorker.isRunning) {\n            replyInterface({\n                kind: 'viteConfig',\n                data: backgroundWorker.config.viteConfig,\n            })\n            Logger.info(`Vite server running as background process. (pid ${backgroundWorker.config.pid})`);\n            return process.exit(0);\n        }\n        \n        const server = await createViteServer({\n            packageJson,\n            refreshNeeded: () => {\n                replyInterface({\n                    kind: 'refreshNeeded',\n                    data: {},\n                })\n            },\n            buildStart: () => {\n                sendViteConfig(replyInterface).catch((error) => {\n                    Logger.error(error);\n                    process.exit(1);\n                });\n            },\n        });\n        \n        await server.listen()\n        listening = true\n        server.printUrls();\n        await sendViteConfig(replyInterface);\n        return;\n    },\n\n    async 'vite.server.stop'() {\n        if (!server) return;\n        try {\n            Logger.info('Shutting down vite server...');\n            await server.close()\n            Logger.info('Vite server shut down successfully!');\n        } catch (error) {\n            Logger.error('Failed to shut down Vite server:', error);\n        }\n    }\n})\n\nasync function createViteServer({\n    packageJson,\n    buildStart,\n    refreshNeeded,\n}: Omit<DevServerOptions, 'meteorParentPid'> & {\n    buildStart: () => void;\n    refreshNeeded: () => void;\n}) {\n    if (server) {\n        return server;\n    }\n    \n    viteConfig = await resolveConfig({\n        configFile: packageJson?.meteor?.vite?.configFile\n            // Fallback for deprecated config format\n            ?? packageJson?.meteor?.viteConfig,\n    }, 'serve');\n    \n    server = await createServer({\n        configFile: viteConfig.configFile,\n        plugins: [\n            meteorWorker({\n               meteorStubs: {\n                   packageJson,\n               }\n            }),\n            {\n                name: 'meteor-handle-restart',\n                buildStart,\n            },\n            {\n                name: 'meteor-ipc-middleware',\n                configureServer: (server) => {\n                    server.middlewares.use('/__meteor__/ipc-message', (req, res, next) => {\n                        let body = '';\n                        req.on('data', (chunk) => {\n                            body += chunk.toString();\n                        });\n                        req.on('end', () => {\n                          const message = JSON.parse(body);\n                          MeteorEvents.ingest(message);\n                          res.statusCode = 204;\n                          next();\n                        })\n                    })\n                }\n            }\n        ],\n    });\n    \n    process.on('warning', (warning) => {\n        if (warning.name !== RefreshNeeded.name) {\n            return;\n        }\n        refreshNeeded();\n    })\n    \n    return server;\n}\n\nasync function sendViteConfig(reply: Replies) {\n    if (!server) {\n        Logger.debug('Tried to get config from Vite server before it has been created!');\n        return;\n    }\n    \n    const { config } = server;\n    const worker = BackgroundWorker.instance;\n    \n    await worker.setViteConfig({\n        host: config.server?.host,\n        port: config.server?.port,\n        entryFile: config.meteor?.clientEntry,\n        resolvedUrls: server.resolvedUrls!,\n    });\n    reply({\n        kind: 'viteConfig',\n        data: worker.config.viteConfig,\n    });\n    reply({\n        kind: 'workerConfig',\n        data: {\n            ...worker.config,\n            listening,\n        },\n    })\n}\n\ntype WorkerRuntimeConfig = {\n    pid: number;\n    meteorPid: number;\n    meteorParentPid: number;\n    viteConfig: ViteRuntimeConfig;\n}\n\nclass BackgroundWorker {\n    public static instance: BackgroundWorker;\n    protected static readonly configPath = process.env.BACKGROUND_WORKER_PID_PATH || Path.join('.meteor', 'local', 'vite', 'vite-dev-server.pid')\n    public static async init(meteorParentPid: number) {\n        if (BackgroundWorker.instance) {\n            return BackgroundWorker.instance;\n        }\n        const myConfig = {\n            pid: process.pid,\n            meteorPid: process.ppid,\n            meteorParentPid,\n            viteConfig: {}\n        };\n        try {\n            await FS.mkdir(Path.dirname(this.configPath), { recursive: true });\n            const content = await FS.readFile(this.configPath, 'utf-8');\n            const config = JSON.parse(content);\n            BackgroundWorker.instance = new BackgroundWorker(config);\n        } catch (error) {\n            BackgroundWorker.instance = new BackgroundWorker(myConfig)\n        }\n        \n        const worker = BackgroundWorker.instance;\n        if (!worker.isRunning) {\n            await worker.update(myConfig);\n            worker._watchForParentExit();\n        } else {\n            Logger.debug(`Background worker should be running with PID: ${worker.config.pid}`, worker.config);\n        }\n        return worker;\n    }\n    constructor(public config: WorkerRuntimeConfig) {}\n    \n    protected _watchForParentExit() {\n        // Keep track of Meteor's parent process to exit if it has ended abruptly.\n        setInterval(() => {\n            if (this._isRunning(this.config.meteorPid)) {\n                return;\n            }\n            Logger.warn('Meteor parent process is no longer running. Shutting down...');\n            this.update({\n                pid: 0,\n                meteorPid: 0,\n                meteorParentPid: 0,\n                viteConfig: {},\n            }).then(() => {\n                process.exit(1);\n            })\n        }, 1_000)\n    }\n    \n    protected _isRunning(pid: number) {\n        try {\n            process.kill(pid, 0);\n            return true;\n        } catch (error) {\n            return false;\n        }\n    }\n    \n    public get isRunning() {\n        if (!this.config.pid) {\n            Logger.debug('No background worker process ID')\n            return false;\n        }\n        if (this.config.pid === process.pid) {\n            Logger.debug(`Background worker's process ID is identical to ours`)\n            return false;\n        }\n        if (!this._isRunning(this.config.pid)) {\n            Logger.debug(`Background worker not running: ${this.config.pid} (current PID ${process.pid}) `);\n            return false;\n        }\n        return true;\n    }\n    \n    public async update(config: WorkerRuntimeConfig) {\n        this.config = config;\n        await FS.writeFile(BackgroundWorker.configPath, JSON.stringify(this.config));\n    }\n    \n    public async setViteConfig(viteConfig: WorkerRuntimeConfig['viteConfig']) {\n        if (this.config.pid !== process.pid && this.isRunning) {\n            Logger.debug(`Skipping Vite config write - config is controlled by different background process: ${this.config.pid}`);\n            return;\n        }\n        await this.update({\n            ...this.config,\n            viteConfig,\n        })\n    }\n}","import { IPCReply } from '../interface';\nimport BuildWorker from './build';\nimport ViteServerWorker from './vite-server';\n\nconst IpcMethods = {\n    ...ViteServerWorker,\n    ...BuildWorker,\n} as const;\n\nexport default IpcMethods;\n\nexport type WorkerMethod = { [key in keyof IPCMethods]: [name: key, method: IPCMethods[key]]\n                           } extends {\n                               [key: string]: [infer Name, infer Method]\n                           } ? Name extends keyof IPCMethods\n                               ? { method: Name, params: Parameters<IPCMethods[Name]> extends [infer Reply, ...infer Params]\n                                                         ? Params\n                                                         : [] }\n                               : never\n                             : never;\n\nexport type WorkerResponse = WorkerReplies[keyof IPCMethods][1];\ntype WorkerReplies = {\n    [key in keyof IPCMethods]: IPCMethods[key] extends (reply: IPCReply<infer Reply>, ...params: any) => any\n                               ? Reply extends { readonly kind: string, data: {} }\n                                 ? [Reply['kind'], Reply]\n                                 : never\n                               : never;\n};\n\nexport type IPCMethods = typeof IpcMethods;\nexport type WorkerResponseData<Kind extends WorkerResponse['kind']> = Extract<WorkerResponse, { kind: Kind }>['data']\nexport type WorkerResponseHooks = {\n    [key in WorkerResponse['kind']]: (data: WorkerResponseData<key>) => void;\n}\n","import { createErrorHandler } from '../error/ErrorHandler';\nimport { validateIpcChannel } from '../meteor/IPC/interface';\nimport IpcMethods, { WorkerMethod } from '../meteor/IPC/methods';\n\nprocess.on('message', async (message: WorkerMethod) => {\n    if (!message || !message.method) {\n        console.error('Vite: Unrecognized worker IPC message', { message });\n        return;\n    }\n    \n    const callWorkerMethod = IpcMethods[message.method];\n    \n    if (typeof callWorkerMethod !== 'function') {\n        console.error(`Vite: The provided IPC method hasn't been defined yet!`, { message });\n    }\n    \n    await callWorkerMethod((response) => {\n        validateIpcChannel(process.send);\n        process.send(response);\n    }, ...message.params as [params: any]).catch(\n        createErrorHandler('Vite: worker process encountered an exception!')\n    );\n})\n\n\nvalidateIpcChannel(process.send);"],"mappings":"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","names":["FS","Path","pc","pc","pc","pc","content","pc","is","isCallExpression","isIdentifier","isMemberExpression","isObjectExpression","isObjectProperty","isStringLiteral","traverse","FS","isObjectExpression","inspect","inspect","exports","isObjectExpression","FS","traverse","is","node","property","isCallExpression","isMemberExpression","isIdentifier","isStringLiteral","exports","isObjectExpression","isObjectProperty","pc","pc","pc","pc","exports","entry","exports","exports","parse","entry","pc","Path","FS","Path","Path","pc","FS","Path","pc","FS","server","stubTemplate","Path","pc","Path","resolveId","config","pc","viteConfig","viteConfig","Path","FS","Path","resolveConfig","server","resolveConfig","Path","FS","viteConfig"]}